<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[swift脚本编程：一键生成AppIcon]]></title>
    <url>%2F2017%2F10%2F17%2Fswift%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%B8%80%E9%94%AE%E7%94%9F%E6%88%90AppIcon%2F</url>
    <content type="text"><![CDATA[自从Xcode8之后就不支持插件了，没法用Xcode一键生成AppIcon，一直没找到好的解决方案，一怒之下决定自己写一个脚本用来生成AppIcon，下面是正文，小弟抛砖引玉，有写的不好的地方有请大佬们见谅： 源码地址 事前准备查看swift版本首先你要确定你的Mac上的swift版本： 1swift --version 我电脑上的执行结果是这样的： 12Apple Swift version 4.0 (swiftlang-900.0.65 clang-900.0.37)Target: x86_64-apple-macosx10.9 然后就可以用Xcode建一个swift文件来编写swift脚本了，不过单独建一个swift文件，Xcode编辑起来非常不友好，我的方案是建一个在Mac上运行的Command Line Tool工程，这样的话有代码提示，要不然写起来太痛苦，如果大佬们有更好的办法，可以指导一下小弟。 swift脚本编程小知识终端输入和输出刚入手脚本我们第一件事前就应该了解在终端如何进行输入和输出，下面是输入和输出的办法： 输出输入很简单，大家也很熟悉，就是print，下面是代码示例： 1print("Hello world!") 然后大家可以执行以下试试（test.swift是你的文件名）： 1swift test.swift 执行后就能在终端上看到一行字：Hello world! 这样子我们的第一个swift脚本就完成了。 输入知道了怎么输出我们还得知道怎么输入，输入也非常简单，下面是代码示例： 1234print("请输入文字：")if let input = readLine() &#123; print("你输入的文字：\(input)")&#125; 执行之后显示的结果： 123请输入文字：Hello world!你输入的文字：Hello world! 这样输入也完成了，我们也算swift脚本编程入门了。 在swift脚本中调用其他脚本我们经常用的脚本有很多，比如echo、mkdir、cd等等，我们能不能在swift中直接调用呢，答案是可以的，下面我们用简单的例子来了解一下，大家想深入的话可以去研究一下传送门： 12345678910111213141516import Foundationfunc execute(path: String, arguments: [String]? = nil) -&gt; Int &#123; let process = Process() process.launchPath = path if arguments != nil &#123; process.arguments = arguments! &#125; process.launch() process.waitUntilExit() return Int(process.terminationStatus) &#125;let status = execute(path: "/bin/ls")print("Status = \(status)") 以上的脚本相当于在终端中执行了ls，如果大家不知道脚本的路径的话，可以用where查找一下，例如： 1where ls 这是执行后的结果： 12ls: aliased to ls -G/bin/ls 这里的/bin/ls就是ls脚本的路径。 开始编写脚本读取input.png首先我们要从将需要转化的图片读取出来，下面是主要代码： 1234567891011import Foundationlet inputPath = "input.png"let inoutData = try Data(contentsOf: url)print("图片大小：\(inoutData.count / 1024) kb")let dataProvider = CGDataProvider(data: inoutData as CFData)if let inputImage = CGImage(pngDataProviderSource: dataProvider!, decode: nil, shouldInterpolate: true, intent: .defaultIntent) &#123; /// inputImage就是需要转化的图片&#125;else &#123; print("转换失败，图片必须是png格式")&#125; 生成AppIcon.appiconset和Contents.json这里就设计到文件操作了，用FileManager就行了，相信大家已经轻车熟路了，我就贴一些主要代码，大家看完整版去我的github源码看就行了: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import Foundation/// AppIcon的modelstruct AppIconImageItem: Codable &#123; let size: String let idiom: String let filename: String let scale: String let role: String? let subtype: String?&#125;struct AppIconInfo: Codable &#123; let version: Int let author: String&#125;struct AppIcon: Codable &#123; var images: [AppIconImageItem] let info: AppIconInfo&#125;/// 创建contentsJson////// - Parameter appIcon: 传入的appIconfunc createAppIconContentsJson(appIcon: AppIcon) &#123; print("\n开始生成contentsJson\n") let encoder = JSONEncoder() do &#123; encoder.outputFormatting = .prettyPrinted let appIconData = try encoder.encode(appIcon) if let appIconStr = String.init(data: appIconData, encoding: .utf8) &#123; let contentJsonPath = "AppIcon.appiconset/Contents.json" let contentJsonUrl = URL(fileURLWithPath: contentJsonPath) try appIconStr.write(to: contentJsonUrl, atomically: true, encoding: .utf8) print("contentsJson生成成功\n") &#125;else &#123; print("contentsJson生成失败") &#125; &#125;catch &#123; print(error.localizedDescription) &#125;&#125;/// 创建appicon文件////// - Parameter appIcon: appiconfunc createFile(appIcon: AppIcon, image: CGImage) &#123; let fileManager = FileManager.default let filePath = "AppIcon.appiconset" do &#123; if fileManager.fileExists(atPath: filePath) &#123; try fileManager.removeItem(atPath: filePath) &#125; try fileManager.createDirectory(atPath: filePath, withIntermediateDirectories: true, attributes: nil) createAppIconContentsJson(appIcon: appIcon) print("~~~~~~~~~~~~~~完成~~~~~~~~~~~~~~") &#125;catch &#123; print("文件目录\(filePath)创建失败") print(error.localizedDescription) &#125;&#125; 生成不同尺寸的image生成图片我们用的是Foundation框架里面的Core Graphics框架，下面是主要代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243import Foundation/// 生成单个image////// - Parameters:/// - size: 图片的size/// - scale: 倍数，例如@2x就是2倍/// - filename: 文件名func createImage(size: CGSize, scale: CGFloat, image: CGImage, filename: String) &#123; print("开始生成图片: \(filename)") let width = Int(size.width * scale) let height = Int(size.height * scale) let bitsPerComponent = image.bitsPerComponent let bytesPerRow = image.bytesPerRow let colorSpace = image.colorSpace if let context = CGContext.init(data: nil, width: width, height: height, bitsPerComponent: bitsPerComponent, bytesPerRow: bytesPerRow, space: colorSpace!, bitmapInfo: CGImageAlphaInfo.premultipliedLast.rawValue) &#123; context.interpolationQuality = .high context.draw(image, in: .init(origin: .zero, size: .init(width: width, height: height))) if let inputImage = context.makeImage() &#123; let outputImagePath = "AppIcon.appiconset/\(filename)" let outputUrl = URL(fileURLWithPath: outputImagePath) as CFURL let destination = CGImageDestinationCreateWithURL(outputUrl, kUTTypePNG, 1, nil) if let destination = destination &#123; CGImageDestinationAddImage(destination, inputImage, nil) if CGImageDestinationFinalize(destination) &#123; print("图片: \(filename) 生成成功\n") &#125;else &#123; print("图片: \(filename) 生成失败\n") &#125; &#125; &#125;else &#123; print("图片: \(filename) 生成失败\n") &#125; &#125;&#125; 最后给大家贴以下完成的截图： 上面只是一部分主要代码，完整的代码太多了，大家可以去我的github地址上去下载执行以下试试，如果有什么做的不好的地方，欢迎大家指教~~ 作者 @W_C__L2017 年 10月 17日]]></content>
      <tags>
        <tag>swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Objective-C编码规范]]></title>
    <url>%2F2017%2F07%2F06%2FObjective-C%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[代码组织在函数分组和protocol/delegate实现中使用#pragma mark -来分类方法，要遵循以下一般结构： 12345678910111213141516171819202122232425262728293031323334353637#pragma mark - Lifecycle- (instancetype)init &#123;&#125;- (void)dealloc &#123;&#125;- (void)viewDidLoad &#123;&#125;- (void)viewWillAppear:(BOOL)animated &#123;&#125;- (void)didReceiveMemoryWarning &#123;&#125;#pragma mark - Custom Accessors- (void)setCustomProperty:(id)value &#123;&#125;- (id)customProperty &#123;&#125;#pragma mark - IBActions- (IBAction)submitData:(id)sender &#123;&#125;#pragma mark - Public- (void)publicMethod &#123;&#125;#pragma mark - Private- (void)privateMethod &#123;&#125;#pragma mark - Protocol conformance#pragma mark - UITextFieldDelegate#pragma mark - UITableViewDataSource#pragma mark - UITableViewDelegate#pragma mark - NSCopying- (id)copyWithZone:(NSZone *)zone &#123;&#125;#pragma mark - NSObject- (NSString *)description &#123;&#125; 空格 缩进使用4个空格，确保在Xcode偏好设置来设置。(raywenderlich.com使用2个空格) 方法大括号和其他大括号(if/else/switch/while 等.)总是在同一行语句打开但在新行中关闭。 应该: 12345if (user.isHappy) &#123; //Do something&#125; else &#123; //Do something else&#125; 不应该: 1234567if (user.isHappy)&#123; //Do something&#125;else &#123; //Do something else&#125; 应该: 123456// blocks are easily readable[UIView animateWithDuration:1.0 animations:^&#123; // something&#125; completion:^(BOOL finished) &#123; // something&#125;]; 不应该: 12345678// colon-aligning makes the block indentation hard to read[UIView animateWithDuration:1.0 animations:^&#123; // something &#125; completion:^(BOOL finished) &#123; // something &#125;]; 作者 @W_C__L2017 年 07月 06日]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[丁香园iOS电话面试问题总结]]></title>
    <url>%2F2017%2F06%2F21%2F%E4%B8%81%E9%A6%99%E5%9B%ADiOS%E7%94%B5%E8%AF%9D%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[写与深夜中，今天下午去面试去面试一家初创公司，然后又接到到了丁香园的电话面试，这篇blog记录一下面试的一些问题，有的回答的还行，有点感觉不太好，主要是有些英文单词说的太low了估计被鄙视了吧，下面给大家总结一下面试的一些问题，有些回答是摘要一些大神blog的出处，都有给原链接，希望见谅~~ 简单讲解一下http请求，以及GET POST的区别这个问得其实不是很难，主要看你了不了解了，我因为了解一些后台的东西，所以回答的还行，下面我给大家看两幅图片大家就基本了解了： 请求Request的原数据 返回Resonse的原数据 总结一下，其实http请求就是发送和接受报文，报文的具体格式就如上图所示，具体由三部分构成，GET 和 POST也就请求方式和参数的位置不同： 请求的方法URL协议/版本 请求头（Request Header） 请求正文（Content） 其中请求头里面可以放很多参数，比如报文的大小啊，啥的一些参数，具体可以百度，这里就不展开了。 https的加密方式和几次握手这个问题回答的就比较菜了，程序比较复制，当时特意记了一下，没想到面试的时候还是有点蒙，回答的非常菜，现在在普及一下，下面是一篇讲的很详细的blog地址，大家可以去原地址去看，我下面也简单总结一下： https的加密方式 对称加密 ​ 对称加密是指加密和解密使用相同密钥的加密算法。它要求发送方和接收方在安全通信之前，商定一个密钥。对称算法的安全性依赖于密钥，泄漏密钥就意味着任何人都可以对他们发送或接收的消息解密，所以密钥的保密性对通信至关重要。 对称加密算法的优、缺点： 优点：算法公开、计算量小、加密速度快、加密效率高。 缺点：1）交易双方都使用同样钥匙，安全性得不到保证； ​ 2）每对用户每次使用对称加密算法时，都需要使用其他人不知道的惟一钥匙，这会使得发收信双方所拥有的钥匙数量呈几何级数增长，密钥管理成为用户的负担。 ​ 3）能提供机密性，但是不能提供验证和不可否认性。 非对称加密 ​ 这种加密或许理解起来比较困难，这种加密指的是可以生成公钥和私钥。凡是公钥加密的数据，公钥自身不能解密，而需要私钥才能解密；凡是私钥加密的数据，私钥不能解密，需要公钥才能解密。这种算法事实上有很多，常用的是RSA，其基于的数学原理是两个大素数的乘积很容易算，而拿到这个乘积去算出是哪两个素数相乘就很复杂了，具体原理有兴趣可以自行研究。 非对称加密相比对称加密更加安全，但也存在两个明显缺点： ​ 1）CPU计算资源消耗非常大。一次完全TLS握手，密钥交换时的非对称解密计算量占整个握手过程的90%以上。而对称加密的计算量只相当于非对称加密的0.1%，如果应用层数据也使用非对称加解密，性能开销太大，无法承受。 ​ 2）非对称加密算法对加密内容的长度有限制，不能超过公钥长度。比如现在常用的公钥长度是2048位，意味着待加密内容不能超过256个字节。 所以公钥加密目前只能用来作密钥交换或者内容签名，不适合用来做应用层传输内容的加解密。 加密的详细过程​ 首先服务器端用非对称加密（RSA）产生公钥和私钥。然后把公钥发给客 户端，路径或许有人会截取，但是没有用，因为用公钥加密的文件只有私钥可以解密，而私钥永远都不会离开服务器的。当公钥到达客户端之后，客户端会用对称加密产生一个秘钥并且用公钥来加密发送给服务器端，这个秘钥就是以后用来通信的钥匙。这样服务器端收到公钥加密的秘钥时就可以用私钥来解公钥从而获得秘钥。这样的话客户端和服务器端都获得了秘钥，信息交流相对是安全的。流程图如下： ​ 听起来确实是挺安全的，但实际上，还有一种更恶劣的攻击是这种方法无 法防范的，这就是传说中的“中间人攻击”。在身份认证的过程中，出现了一个“中间人”拦截我们的信息，他有意想要知道你们的消息。我们将这个中间人称为M。当服务器第一次给客户端发送公钥的时候，途径M。M知道你要进行密钥交换了，它把公钥扣了下来，假装自己是客户端，伪造了一个伪秘钥（对称加密产生的），然后用服务器发来的公钥加密了伪秘钥发还给服务器，这样服务器以为和客户端完成了密钥交换，实际上服务器是和M完成了密钥交换（获得了伪秘钥）。同时M假扮成服务器自行用非对称加密产生伪公钥和伪私钥，与客户端进行秘钥交换，拿到客户端发送过来的秘钥。现在客户端拿着秘钥，M拿着秘钥和为伪秘钥，服务器拿着伪秘钥，整个交流的过程就是： 还有很多大家直接去大神的blog去看吧，写的很详细，我这就点到为止了~~ 在不知道二进制文件格式的情况下如何区分文件当听到这么问题的时候还是有点仓促的，隐约记得是通过二进制的头部的标识来区分的，当时也不太确定就含糊的回答了一下，说是通过二进制文件的头部标识来区分的，看面试官的样子不是很满意，回答百度学习一波，百度结果如下所示，附带原链接： 可以通过二进制头识别文件类型，可以使用UE或者WinHex软件打开： JPEG/JPG 文件头标识 (2 bytes): $ff, $d8 (SOI) (JPEG文件标识) 文件结束标识 (2 bytes): $ff, $d9 (EOI) TGA 未压缩的前5字节 00 00 02 0000 RLE压缩的前5字节 00 00 10 0000 PNG 文件头标识 (8 bytes) 89 50 4E 470D 0A 1A 0A GIF 文件头标识 (6 bytes) 47 49 46 3839(37) 61 ​ G I F 8 9 (7) a BMP 文件头标识 (2 bytes) 424D ​ B M PCX 文件头标识 (1 bytes) 0A TIFF 文件头标识 (2 bytes) 4D 4D 或 4949 ICO 文件头标识 (8 bytes) 00 00 01 0001 00 20 20 CUR 文件头标识 (8 bytes) 00 00 02 0001 00 20 20 IFF 文件头标识 (4 bytes) 46 4F 524D ​ F O R M ANI 文件头标识 (4 bytes) 52 49 4646 ​ R I F F 以上是一些文件的区别方式，回答的总方向还是对的，可能回答的不够好，下次就知道了。 常见的几种线程锁这个问题比较尴尬，因为英文不太好，加上平时用的也不多，回答的比较吞吞吐吐，就说了NSLock、@synchronized和dispatch的semaphore，其中有些单词的读法还不太准，想想就很尴尬，下面大概总结一下，有一下几种： NSLock @synchronized dispatch的semaphore 条件锁NSCondition 条件锁NSConditionLock NSDistributedLock 互斥锁POSIX 自旋锁OSSpinLock 下面总结一下，说实话太多有点记不过来了 - . -，附带详细的原文地址： 各种线程锁 使用场景和简单介绍 @synchronized 适用线程不多，任务量不大的多线程加锁 NSLock 比较常用的一种锁，性能一般 dispatch_semaphore_t 使用信号来做加锁，性能很好 NSCondition 使用其做多线程之间的通信调用不是线程安全的 NSConditionLock 单纯加锁性能非常低，比NSLock低很多，但是可以用来做多线程处理不同任务的通信调用 NSRecursiveLock 递归锁的性能出奇的高，但是只能作为递归使用,所以限制了使用场景 NSDistributedLock 因为是MAC开发的，就不讨论了 POSIX(pthread_mutex) 底层的api，复杂的多线程处理建议使用，并且可以封装自己的多线程 OSSpinLock 性能也非常高，可惜出现了线程问题 再总计一下，总的意思就是一般用dispatch_semaphore_t就行了，再简单点用NSLock，另外带一个swift出的一个线程锁的方式： 12345func synchronized(lock: AnyObject, closure: () -&gt; ()) &#123; objc_sync_enter(lock) closure() objc_sync_exit(lock)&#125; 怎么保证线程安全这个问题我是接着上一个问题之后回答的，感觉线程安全主要是数据竞争带来的，下面简单讲解一下： 1线程安全的代码可以从多个线程或并发任务安全地调用，而不会造成任何问题（数据损坏，系统崩溃等）。例如当你多线程编程时，你用let定义一个数组，因为它是只读的，你能在同一时间不同线程去使用它，而不会造成线程安全的问题，然而当你用var定义一个数组时就不一样了，它不是线程安全的，当多个线程在同一时间访问和修改数组时会产生不可预知的结果。 SDWebImage具体实现和具体类这个问题回答的一般般吧，说了一下简单的构造和实现，然后让我说具体类的时候有点心累了，因为确实记得不是很清楚了，下面简单总结一下一些主要的类： SDWebImageManager SDWebImageCombinedOperation SDImageCache SDWebImageDownloader 各种类目 这是一些简单的类，大家想要详细了解可以去这篇文章去看，非常详细！！！ Alamofire实现原理和主要的类跟上个问题一样，简单的回答了一下，都怪自己没仔细专研过这些，只是简单看过，停留在应用层面上，下面同样简单介绍一下，附带大神blog地址吧： Manager SessionDelegate ResponseSerialization URLStringConvertible 这是一些简单的类，大家想要详细了解可以去这篇文章去看，非常详细！！！ RxSwift的原理使用和主要类？这个幸好用过了，不过也没深入过，就简单抽象的讲了一下响应式编程的思想，然后从应用使用方面讲解了一下：RxSwift的目的是让让数据/事件流和异步任务能够更方便的序列化处理，能够使用swift进行响应式编程；让后让我说一下RxSwift里面有哪些Subjects，这个就比较尴尬了，这让我只用过PublishSubject和Driver的人情何以堪，下面同样列一下Subjects列表和大神地址： PublishSubject ReplaySubject BehaviorSubject Variable Driver 下面是大神blog，有详细介绍大家可以去阅读123456789101112131415161718192021222324252627282930# realm的简单介绍和使用时的线程问题这个也简单用过，也是没往深入研究，也是大概说了一下使用过程，和多线程数据共享的坑，首先`realm`是一个跨平台移动数据库引擎，支持`iOS`、`OS X`（`Objective-C`和`Swift`）以及`Android`，核心数据引擎`C++`打造，并不是建立在`SQLite`之上的`ORM`。## 跨线程时的使用废话不多说，直接上代码：```swiftlet person = Person(name: &quot;Jane&quot;)try! realm.write &#123; realm.add(person)&#125;// 以下是跨线程必要的操作，先建一个Referencelet personRef = ThreadSafeReference(to: person)// 然后在需要返回数据的线程里面去resolveDispatchQueue(label: &quot;background&quot;).async &#123; let realm = try! Realm() guard let person = realm.resolve(personRef) else &#123; // person 已被删除 return &#125; try! realm.write &#123; person.name = &quot;Jane Doe&quot; &#125;&#125;```这里是[官方中文文档](https://realm.io/cn/docs/swift/latest/)，大家可以去看看，非常详细 简单讲一讲RunTime和RunLoopruntimer和runloop因为看过一篇文章写的特别好，有一定了解，说了runtime的一些主要功能和应用的地方，下面简单介绍一下： RunTime RunTime简称运行时； OC就是运行时机制，就是在运行的时候调用一些机制； 对于C语言，在编译的时候会决定调用哪个函数； 对于OC，在编译的时候并不能决定调用哪个函数，只有在真正运行的时候才会根据函数的SEL来调用对应的函数。 RunTime 应用范围 发送消息 交换方法 动态添加方法 动态添加属性 其中用的比较多的就是用类目给某个类动态添加属性。 RunLoopRunLoop简单来说就是事件循环，保持APP一直处于存活方式的一种机制，让线程能随时处理事件但并不退出，下面有一篇超级棒的RunLoop文章给大家介绍一下，我这就不展开说了，了解RunLoop看那篇文章足够了。 超级棒的文章地址 简单说一下iOS的几种持续化存储方式这个回答的就比较轻松了，下面随便列几个吧，大家有其他的可以补充一下： NSUserDefaults plist NSKeyedArchiver SQL coredata realm WKWebView缓存和清理缓存的方法WKWebView缓存的使用主要通过NSURLCache对请求的数据进行缓存，具体实现可以去这个github上去查看123456789101112131415161718## 清楚缓存的方法详情看这篇[blog](http://www.jianshu.com/p/186a3b236bc9)，这里简单陈述一下，其实在`iOS9`出了一个方法，调用一下就清除了：```objective-cNSSet *websiteDataTypes = [WKWebsiteDataStore allWebsiteDataTypes];//// Date fromNSDate *dateFrom = [NSDate dateWithTimeIntervalSince1970:0];//// Execute[[WKWebsiteDataStore defaultDataStore] removeDataOfTypes:websiteDataTypes modifiedSince:dateFrom completionHandler:^&#123;// Done&#125;];```# WKWebview的cookie的使用主要用到的类有`NSHTTPCookie`，大家同样也可以去[大神的blog](http://www.jianshu.com/p/7062916177ac)去查看 autorelease的实现，以及autorelease对象什么时候会被release这个问题回答的不太好，说实话当时连续面试了两家，闹着已经有点蒙了，这里借用喵神翻译的一本书上的原话来描述一下： ​ autorelease它会将接受该消息的对象放到一个预先建立的自动释放池 (auto release pool) 中，并在 自动释放池收到 drain 消息时将这些对象的引用计数减一，然后将它们从池子中移除 (这一过程形象地称为“抽干池子”)。” 【摘录来自: 王巍 (onevcat). “Swifter - Swift 必备 Tips (第三版)”。 iBooks. 】 实现原理的话大概就是被autorelease标记的类会被加入一个池子，当这个池子drain时里面的引用计数会减1。 swift写时复制，自己的结构体怎么实现写时复制幸好之前看了喵神翻译的【Swift进阶】 ，受益颇深，下面同样借用喵神的话给大家简单描述一下，大家可以去买这本书，还是挺划算的，下面大量复制喵神书里面的内容，请见谅： 在 Swift 标准库中，像是 Array，Dictionary 和 Set 这样的集合类型是通过一种叫做写时复制 (copy-on-write) 的技术实现的。我们这里有一个整数数组： 12var x = [1,2,3]var y = x 如果我们创建了一个新的变量 y，并且把 x 赋值给它时，会发生复制，现在 x 和 y 含有的是独立的结构体。在内部，这些 Array 结构体含有指向某个内存的引用。这个内存就是数组中元素所存储的位置，它们位于堆 (heap) 上。在这个时候，两个数组的引用指向的是内存中同一个位置，这两个数组共享了它们的存储部分。不过，当我们改变 x 的时候，这个共享会被检测到，内存将会被复制。这样一来，我们得以独立地改变两个变量。昂贵的元素复制操作只在必要的时候发生，也就是我们改变这两个变量的时候发生复制： 1234x.append(5)y.removeLast()x // [1, 2, 3, 5]y // [1, 2] 如果 Array 结构体中的引用在数组被改变的一瞬间时是唯一的话 (比如，没有声明 y)，那么也不会有复制发生，内存的改变将在原地进行。这种行为就是写时复制，作为一个结构体的作者，你并不能免费获得这种特性，你需要自己进行实现。当你自己的类型内部含有一个或多个可变引用，同时你想要保持值语义，并且避免不必要的复制时，为你的类型实现写时复制是有意义的。 下面看看通过简单的例子看一下： 123456var array = [COWStruct()]array[0].change() // No copyvar otherArray = [COWStruct()]var x = array[0]x.change() // Copy 然而自己去实现一个写时复制的话，首先你要判断引用的唯一性，不是唯一的话进行写时复制，唯一的话直接改变需要改变的值。 结构体和类以及它们的使用时机结构体和类主要的区别就是一个是值类型，一个是引用类型；值类型是写时复制的，引用类型是不会发生写时复制的；当我们需要一个简单不需要继承、不多变的数据时候我们首选结构体，因为在数据结构上来说结构体的存取效率是高于类的，反之当我们需要一个数据结构比较大，需要继承，变化比较多的时候我们选择类，因为在变化的过程中结构体可能会发生写时复制，而类不会；下面举一个简单的例子： 以Array和NSMutableArray来说： 当有一个数组，数据量相对比较小，也不用去经常改变它，只是用来存数据和取数据，我们首先Array 当数组的数据量很大的时候，并且经常要去对他进行添加，删除等操作，并且经常赋值给其他变量的话就推荐使用NSMutableArray 让你实现一个数据存储的框架怎么去实现这个是一个比较开发性的问题了，我想到的是用策略模式的方式来简单实现一下，使用策略模式的好处是方便文件类型的扩展，下面我简单画个简单的UML图大家看一看吧： 当然这只是一个初步的模型，还有很多细节待考虑，比如文件缓存什么的，是存本地还是磁盘，这都得去考虑，小弟只是抛砖引玉给个简单的思路。 写完已经是深夜了，以上是我丁香园电话面试的一些问题，和之前面试一些回答不好的问题，最后面试完我问了一下丁香园的面试官对我感觉怎样，他说广度还行深度不够，我确实又有这点问题，想学的知识比较多，有时候也没来得及去看实现原理，只是简单的过一下，没深入研究透彻，这是我需要加强的地方，之后如果有二面的话我会在继续更新的，最后谢谢大家的阅读~~我是WCL，大家可以去我github关注一波 作者 @W_C__L2017 年 06月 21日]]></content>
      <categories>
        <category>面试小结</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS动画进阶 - 实现炫酷的上拉刷新动效（二）]]></title>
    <url>%2F2017%2F04%2F27%2FiOS%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6-%E5%AE%9E%E7%8E%B0%E7%82%AB%E9%85%B7%E7%9A%84%E4%B8%8A%E6%8B%89%E5%88%B7%E6%96%B0%E5%8A%A8%E6%95%88%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[最近撸了一个上拉刷新的小轮子，只要遵循一个协议就能自定义自己动效的上拉刷新和加载，我自己也写了几个动效进去，下面是一个比较好的动效的实现过程 先上效果图和github地址，完整代码个demo和进入查看，有其他好的动效大家也可以学习交流~ 分析动效写一个动效的第一步就应该仔细的去分析它，把它的每一帧展开来看，找一个最合适的方式来实现它，我们可以把以上动画分解成以下三个步骤： 箭头的绘制和动效 圆环的绘制和小点的旋转 对勾的绘制和动画 以下是会用到主要的类： CAShapeLayer UIBezierPath CABasicAnimation CAKeyframeAnimation DispatchSourceTimer 箭头的绘制和动效剪头的绘制我们用CAShapeLayer配合UIBezierPath来实现，把箭头分解成两个部分，一个是垂直的线和箭头头的部分，方便实现之后的动画效果，下面是绘制主要的代码和效果图： 12345678910111213141516171819202122232425262728293031323334// 绘制垂直的线private func initLineLayer() &#123; let width = frame.size.width let height = frame.size.height let path = UIBezierPath() path.move(to: .init(x: width/2, y: 0)) path.addLine(to: .init(x: width/2, y: height/2 + height/3)) lineLayer = CAShapeLayer() lineLayer?.lineWidth = lineWidth*2 lineLayer?.strokeColor = color.cgColor lineLayer?.fillColor = UIColor.clear.cgColor lineLayer?.lineCap = kCALineCapRound lineLayer?.path = path.cgPath lineLayer?.strokeStart = 0.5 addSublayer(lineLayer!)&#125;// 绘制箭头的头部private func initArrowLayer() &#123; let width = frame.size.width let height = frame.size.height let path = UIBezierPath() path.move(to: .init(x: width/2 - height/6, y: height/2 + height/6)) path.addLine(to: .init(x: width/2, y: height/2 + height/3)) path.addLine(to: .init(x: width/2 + height/6, y: height/2 + height/6)) arrowLayer = CAShapeLayer() arrowLayer?.lineWidth = lineWidth*2 arrowLayer?.strokeColor = color.cgColor arrowLayer?.lineCap = kCALineCapRound arrowLayer?.lineJoin = kCALineJoinRound arrowLayer?.fillColor = UIColor.clear.cgColor arrowLayer?.path = path.cgPath addSublayer(arrowLayer!)&#125; 然后是箭头动画实现，我们分别对线和箭头头部进行动画，通过CABasicAnimation对它们的strokeStart和strokeEnd进行控制来实现动画，下面是效果图和主要代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// 箭头的动画public func startAnimation() -&gt; Self &#123; let start = CABasicAnimation(keyPath: "strokeStart") start.duration = animationDuration start.fromValue = 0 start.toValue = 0.5 start.isRemovedOnCompletion = false start.fillMode = kCAFillModeForwards start.delegate = self start.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseInEaseOut) let end = CABasicAnimation(keyPath: "strokeEnd") end.duration = animationDuration end.fromValue = 1 end.toValue = 0.5 end.isRemovedOnCompletion = false end.fillMode = kCAFillModeForwards end.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseInEaseOut) arrowLayer?.add(start, forKey: "strokeStart") arrowLayer?.add(end, forKey: "strokeEnd") return self&#125;// 线的动画private func addLineAnimation() &#123; let start = CABasicAnimation(keyPath: "strokeStart") start.fromValue = 0.5 start.toValue = 0 start.isRemovedOnCompletion = false start.fillMode = kCAFillModeForwards start.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseInEaseOut) start.duration = animationDuration/2 lineLayer?.add(start, forKey: "strokeStart") let end = CABasicAnimation(keyPath: "strokeEnd") end.beginTime = CACurrentMediaTime() + animationDuration/3 end.duration = animationDuration/2 end.fromValue = 1 end.toValue = 0.03 end.isRemovedOnCompletion = false end.fillMode = kCAFillModeForwards end.delegate = self end.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseInEaseOut) lineLayer?.add(end, forKey: "strokeEnd")&#125;// 通过delegate控制顺序func animationDidStop(_ anim: CAAnimation, finished flag: Bool) &#123; if flag &#123; if let anim = anim as? CABasicAnimation &#123; if anim.keyPath == "strokeStart" &#123; arrowLayer?.isHidden = true addLineAnimation() &#125;else &#123; lineLayer?.isHidden = true animationEnd?() &#125; &#125; &#125;&#125; 圆环的绘制和小点的旋转同样的圆环和小店的绘制我们也可以用CAShapeLayer配合UIBezierPath来实现 ，下面是效果图和主要代码： 123456789101112131415161718192021222324252627// 绘制外环private func drawCircle() &#123; let width = frame.size.width let height = frame.size.height let path = UIBezierPath() path.addArc(withCenter: .init(x: width/2, y: height/2), radius: height/2, startAngle: 0, endAngle: CGFloat(Double.pi * 2.0), clockwise: false) circle.lineWidth = lineWidth circle.strokeColor = color.cgColor circle.fillColor = UIColor.clear.cgColor circle.path = path.cgPath addSublayer(circle) circle.isHidden = true&#125;// 绘制小点private func drawPoint() &#123; let width = frame.size.width let path = UIBezierPath() path.addArc(withCenter: .init(x: width/2, y: width/2), radius: width/2, startAngle: CGFloat(Double.pi * 1.5), endAngle: CGFloat((Double.pi * 1.5) - 0.1), clockwise: false) point.lineCap = kCALineCapRound point.lineWidth = lineWidth*2 point.fillColor = UIColor.clear.cgColor point.strokeColor = pointColor.cgColor point.path = path.cgPath pointBack.addSublayer(point) point.isHidden = true&#125; 旋转的实现，因为旋转的速度是有个加速的效果的，所以我们使用DispatchSourceTimer来控制选择的速度，下面是效果图和主要代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 旋转的控制public func startAnimation() &#123; circle.isHidden = false point.isHidden = false codeTimer = DispatchSource.makeTimerSource(queue: DispatchQueue.global()) codeTimer?.scheduleRepeating(deadline: .now(), interval: .milliseconds(42)) codeTimer?.setEventHandler(handler: &#123; [weak self] in guard self != nil else &#123; return &#125; self!.rotated = self!.rotated - self!.rotatedSpeed if self!.stop &#123; let count = Int(self!.rotated / CGFloat(Double.pi * 2)) if (CGFloat(Double.pi * 2 * Double(count)) - self!.rotated) &gt;= 1.1 &#123; var transform = CGAffineTransform.identity transform = transform.rotated(by: -1.1) DispatchQueue.main.async &#123; self!.pointBack.setAffineTransform(transform) self!.point.isHidden = true self!.check?.startAnimation() &#125; self!.codeTimer?.cancel() return &#125; &#125; if self!.rotatedSpeed &lt; 0.65 &#123; if self!.speedInterval &lt; 0.02 &#123; self!.speedInterval = self!.speedInterval + 0.001 &#125; self!.rotatedSpeed = self!.rotatedSpeed + self!.speedInterval &#125; var transform = CGAffineTransform.identity transform = transform.rotated(by: self!.rotated) DispatchQueue.main.async &#123; self!.pointBack.setAffineTransform(transform) &#125; &#125;) codeTimer?.resume() addPointAnimation()&#125;// 点的变化private func addPointAnimation() &#123; let width = frame.size.width let path = CABasicAnimation(keyPath: "path") path.beginTime = CACurrentMediaTime() + 1 path.fromValue = point.path let toPath = UIBezierPath() toPath.addArc(withCenter: .init(x: width/2, y: width/2), radius: width/2, startAngle: CGFloat(Double.pi * 1.5), endAngle: CGFloat((Double.pi * 1.5) - 0.3), clockwise: false) path.toValue = toPath.cgPath path.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseOut) path.duration = 2 path.isRemovedOnCompletion = false path.fillMode = kCAFillModeForwards point.add(path, forKey: "path")&#125; 对勾的绘制和动画对勾的绘制我们也是用CAShapeLayer配合UIBezierPath来绘制，下面是效果图和主要的代码： 1234567891011121314151617181920// 绘制对号private func drawCheck() &#123; let width = Double(frame.size.width) check = CAShapeLayer() check?.lineCap = kCALineCapRound check?.lineJoin = kCALineJoinRound check?.lineWidth = lineWidth check?.fillColor = UIColor.clear.cgColor check?.strokeColor = color.cgColor check?.strokeStart = 0 check?.strokeEnd = 0 let path = UIBezierPath() let a = sin(0.4) * (width/2) let b = cos(0.4) * (width/2) path.move(to: CGPoint.init(x: width/2 - b, y: width/2 - a)) path.addLine(to: CGPoint.init(x: width/2 - width/20 , y: width/2 + width/8)) path.addLine(to: CGPoint.init(x: width - width/5, y: width/2 - a)) check?.path = path.cgPath addSublayer(check!)&#125; 对勾的动画我们通过CAKeyframeAnimation来控制对勾的strokeStart和strokeEnd来实现对勾的动画，下面是效果图和主要代码： 1234567891011121314151617181920// 对勾的动画func startAnimation() &#123; let start = CAKeyframeAnimation(keyPath: "strokeStart") start.values = [0, 0.4, 0.3] start.isRemovedOnCompletion = false start.fillMode = kCAFillModeForwards start.duration = 0.2 start.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseInEaseOut) let end = CAKeyframeAnimation(keyPath: "strokeEnd") end.values = [0, 1, 0.9] end.isRemovedOnCompletion = false end.fillMode = kCAFillModeForwards end.duration = 0.3 end.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseInEaseOut) check?.add(start, forKey: "start") check?.add(end, forKey: "end")&#125; 总结关于小球的旋转我没有选择CADisplayLink而是选择的DispatchSourceTimer，是因为CADisplayLink会受到UITableview的影响，关于动画的实现需要耐心去调细节，实现方式也各种各样，大家如果有什么更好的建议或者建议大家可以提出来~ 完整的代码，大家可以去github地址去下载，欢迎大家star和发表意见和贡献代码，有好的动效的话也可以提供，最后谢谢大家的阅读 作者 @W_C__L2017 年 03月17日]]></content>
      <categories>
        <category>iOS动画进阶</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS动画进阶 - 实现炫酷的上拉刷新动效]]></title>
    <url>%2F2017%2F03%2F17%2FiOS%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6-%E5%AE%9E%E7%8E%B0%E7%82%AB%E9%85%B7%E7%9A%84%E4%B8%8A%E6%8B%89%E5%88%B7%E6%96%B0%E5%8A%A8%E6%95%88%2F</url>
    <content type="text"><![CDATA[最近撸了一个上拉刷新的小轮子，只要遵循一个协议就能自定义自己动效的上拉刷新和加载，我自己也写了几个动效进去，下面是一个比较好的动效的实现过程 先上效果图和github地址，有其他好的动效大家也可以交流~ 动效的原地址，在uimovement网站上看到这个动效时感觉特别6，就想自己实现一下，费了很长时间，换了几种方案终于实现出来了，下面是实现的步骤： 分析动效写一个动效的第一步就应该仔细的去分析它，把它的每一帧展开来看，找一个最合适的方式来实现它，下面是我分析过程： 看到曲线，肯定会想到CAShapeLayer和UIBezierPath这一对搭档，相对于CoreGraphics而言，它即简单有高效； 曲线的拉拽效果可以用 CADisplayLink加上一个参考的view，以参考view为UIBezierPath的一个controlPoint，移动参考view来实现曲线拉拽的效果； 曲线的回弹效果考虑再三后决定使用CAKeyframeAnimation配合CAShapeLayer来使用，本来打算使用CASpringanimation来实现，但是考虑它是iOS9出的，而我的轮子最低支持iOS8，就放弃用它了； 小球是实现和弹出就相对简单了，使用CAShapeLayer来实现小球，用CABasicAnimation来实现小球的移动； 小球外层圆环旋转的效果，首先也是用CAShapeLayer来实现圆环，然后配合CABasicAnimation控制CAShapeLayer的strokeEnd和transform.rotation.z一直来实现外层圆环旋转的效果； 最后就是比较复杂的就是小球和曲线的连接处的处理，我的实现方式是通过CADisplayLink在动画的过程中实时的去监听小球和曲线的位置，计算出UIBezierPath用一个CAShapeLayer来精确的连接小球和曲线部分。 好了，以上是大概过程，如果大家有另外的更好的实现方式，也可以一起来讨论。 绘制曲线和曲线的拉拽我们用CAShapeLayer和UIBezierPath这一对搭档来实现曲线的绘制，下面以一个参考view来给大家演示一下，下面是主要代码和效果图： 123456789101112131415161718192021222324252627282930// 通过传递的y坐标来绘制曲线func wave(_ y: CGFloat, execute: CGFloat) &#123; self.execute = execute waveLayer.path = wavePath(x: 0, y: y) if !isAnimation &#123; var trans = CGAffineTransform.identity trans = trans.translatedBy(x: 0, y: y) reference.transform = trans &#125;&#125;// 计算pathprivate func wavePath(x: CGFloat, y: CGFloat) -&gt; CGPath &#123; let w = frame.width let path = UIBezierPath() if y &lt; execute &#123; path.move(to: .zero) path.addLine(to: .init(x: w, y: 0)) path.addLine(to: .init(x: w, y: y)) path.addLine(to: .init(x: 0, y: y)) path.addLine(to: .zero) &#125;else &#123; path.move(to: .zero) path.addLine(to: .init(x: w, y: 0)) path.addLine(to: .init(x: w, y: execute)) path.addQuadCurve(to: .init(x: 0, y: execute), controlPoint: .init(x: w/2, y: y)) path.addLine(to: .zero) &#125; return path.cgPath&#125; 曲线的回弹效果曲线的回弹使用CAKeyframeAnimation加到参考的view上，然后用CADisplayLink监听参考view的坐标做为controlPoint来实现曲线的回弹效果，下面是主要代码和效果图： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 开始动画func startAnimation() &#123; isAnimation = true addDisPlay() boundAnimation(x: 0, y: execute)&#125;// CAKeyframeAnimation动画private func boundAnimation(x: CGFloat, y: CGFloat) &#123; let bounce = CAKeyframeAnimation(keyPath: "transform.translation.y") bounce.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseIn) bounce.duration = bounceDuration bounce.values = [ reference.frame.origin.y, y * 0.5, y * 1.2, y * 0.8, y * 1.1, y ] bounce.isRemovedOnCompletion = true bounce.fillMode = kCAFillModeForwards bounce.delegate = self reference.layer.add(bounce, forKey: "return")&#125;// 添加和移除CADisplayLinkprivate func addDisPlay() &#123; displayLink = CADisplayLink(target: self, selector: #selector(displayAction)) displayLink?.add(to: .main, forMode: .commonModes)&#125;private func removeDisPlay() &#123; displayLink?.invalidate() displayLink = nil&#125;// CADisplayLink绑定的方法@objc private func displayAction() &#123; if let frame = reference.layer.presentation()?.frame &#123; DispatchQueue.global().async &#123; let path = self.displayWavePath(x: 0, y: frame.origin.y + referenceHeight/2) DispatchQueue.main.async &#123; self.waveLayer.path = path &#125; &#125; &#125;&#125;// 通过这个方法获取pathprivate func displayWavePath(x: CGFloat, y: CGFloat) -&gt; CGPath &#123; let w = frame.width let path = UIBezierPath() path.move(to: .zero) path.addLine(to: .init(x: w, y: 0)) path.addLine(to: .init(x: w, y: execute)) path.addQuadCurve(to: .init(x: 0, y: execute), controlPoint: .init(x: w/2, y: y)) path.addLine(to: .zero) return path.cgPath&#125; 外层圆环的动画小球和外层圆环我们用CAShapeLayer来绘制，这里主要讲的是动画的实现，动画主要由两个部分组成： CABasicAnimation控制外层圆环的strokeEnd的动画； CABasicAnimation控制外层圆环的transform.rotation.z的旋转动画； 外层圆环的strokeEnd动画 外层圆环的transform.rotation.z的旋转动画 下面是关键代码： 1234567891011121314151617181920212223242526func animation() &#123; self.isHidden = false let rotate = CABasicAnimation(keyPath: "transform.rotation.z") rotate.fromValue = 0 rotate.toValue = M_PI * 2 rotate.duration = 1 rotate.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionLinear) rotate.repeatCount = HUGE rotate.fillMode = kCAFillModeForwards rotate.isRemovedOnCompletion = false self.add(rotate, forKey: rotate.keyPath) strokeEndAnimation()&#125;func strokeEndAnimation() &#123; let endPoint = CABasicAnimation(keyPath: "strokeEnd") endPoint.fromValue = 0 endPoint.toValue = 1 endPoint.duration = 1.8 endPoint.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseOut) endPoint.repeatCount = HUGE endPoint.fillMode = kCAFillModeForwards endPoint.isRemovedOnCompletion = false endPoint.delegate = self add(endPoint, forKey: endPoint.keyPath)&#125; 小球上升和连接处的处理小球上升动画很简单，一个CABasicAnimation动画就实现了，主要麻烦的是连接处的动画实现，我的方案是在小球动画过程中通过CADisplayLink实时监听小球和参考view的位置，计算出贝斯尔曲线，然后通过一个名为linkLayer: CAShapeLayer的layer来连接它们，然后让它们在特定的地方断开，下面是主要代码和效果图： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@objc private func displayAction() &#123; let offY = ballLayer.circleLayer.presentation()?.frame.origin.y let frame1 = ballLayer.frame let frame2 = wavelayer.reference.layer.presentation()?.frame if let offY = offY, let frame2 = frame2 &#123; DispatchQueue.global().async &#123; // 判断是球是向上还是下，false为上,速度快时，获取的位置不及时，向下时需要调整位置 let isIncrement = (offY - self.previousOffY) &gt; 0 let path = UIBezierPath() let x1 = frame1.origin.x + (isIncrement ? 4 : 0) let y1 = frame1.origin.y + offY let w1 = frame1.size.width - (isIncrement ? 8 : 0) let h1 = frame1.size.height let x2 = frame2.origin.x let y2 = frame2.origin.y let w2 = frame2.size.width let h2 = frame2.size.height let subY = y2 - y1 // y1和y2的间距 let subScale = subY/self.execute/2 // 断开的距离为10 let executeSub = self.ballLayer.circleLayer.moveUpDist + offY if executeSub &lt; 10 &#123; if !isIncrement &#123; let executeSubScale = executeSub/10 path.move(to: .init(x: x1 - 15, y: y2 + h2/2 + 15)) path.addLine(to: .init(x: x1 + w1 + 15, y: y2 + h2/2 + 15)) path.addQuadCurve(to: .init(x: x1 - 15, y: y2 + h2/2 + 15), controlPoint: .init(x: x1 + w1/2, y: y2 + h2/2 - self.execute/6 * executeSubScale)) &#125; &#125;else &#123; path.move(to: .init(x: x2 , y: y2 + h2)) path.addLine(to: .init(x: x2 + w2, y: y2 + h2)) path.addQuadCurve(to: .init(x: x1 + w1, y: y1 + h1/2), controlPoint: .init(x: x1 + w1 - w1*2*subScale, y: y1 + (y2 - y1)/2 + h1/2 + h2/2)) path.addLine(to: .init(x: x1, y: y1 + h1/2)) path.addQuadCurve(to: .init(x: x2 , y: y2 + h2), controlPoint: .init(x: x1 + w1*2*subScale, y: y1 + (y2 - y1)/2 + h1/2 + h2/2)) if y1 + h1 &lt;= self.execute, isIncrement &#123; DispatchQueue.main.async &#123; self.wavelayer.startDownAnimation() &#125; &#125; &#125; DispatchQueue.main.async &#123; self.linkLayer.path = path.cgPath &#125; self.previousOffY = offY &#125; &#125;&#125; 我觉得我这个地方的处理不是很好，但是简单粗暴的解决了问题，如果大家有更好的建议，可以提出来，大家一起交流学习~ 完整的代码，大家可以去github地址去下载，欢迎大家star和发表意见和贡献代码，有好的动效的话也可以提供，最后谢谢大家的阅读 作者 @W_C__L2017 年 03月17日]]></content>
      <categories>
        <category>iOS动画进阶</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手把手教你发布自己的开源框架到CocoaPods]]></title>
    <url>%2F2017%2F03%2F17%2F%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%8F%91%E5%B8%83%E8%87%AA%E5%B7%B1%E7%9A%84%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E5%88%B0CocoaPods%2F</url>
    <content type="text"><![CDATA[偶尔会发布自己的开源框架到CocoaPods上，但是每次都忘记命令行，写这篇博客的目的是为了记录下来步骤，方便以后翻阅使用 一、先将代码传到github上这步比较简单，大致说一下： 12345678910// 创建本地仓库git init// 添加名称为origin的远程连接git remote add origin &apos;你的github项目地址&apos;// 将本地代码加入本地仓库里git add .// 提交修改到本地仓库git commit -m &apos;你的修改记录&apos;// 推送master分支的代码到名称为origin的远程仓库git push origin master 二、给你git打上tag打tag的目的就相当于给你的开源框架制定版本号，每个版本一个tag，下面是打tag的流程： 123456// 查看本地taggit tag// 添加本地tag 1.0.0git tag -a 1.0.0 -m &apos;release 1.0.0&apos;// 将tag传到远程git push origin --tags tag的其他操作1234// 删除本地taggit tag -d 1.0.0// 删除远程taggit push origin -d tag 1.0.0 三、注册Trunk1pod trunk register 你的邮箱 &apos;你的用户名&apos; --description=&apos;你的描述&apos; 成功的话就会受到一份邮件，点击邮件中的链接后验证一下： 1pod trunk me 成功的话会返回以下类似字段： 123456789- Name: WCL- Email: wangchonglei93@icloud.com- Since: January 10th, 21:32- Pods: - WCLImagePickerController - WCLShineButton - CRRefresh- Sessions: - January 10th, 21:32 - July 22nd, 07:38. IP: 58.132.205.59 如果你的pod是由多人维护的，你也可以添加其他维护者： 1pod trunk add-owner ARAnalytics kyle@cocoapods.org 四、创建自己项目的Podspec描述文件上传到cocoapods时主要就依赖着.podspec的描述文件来进行配置的，所以我们要先建立一个.podspec的描述文件： 12// 初始化.podspec文件pod spec create 你的项目名 初步了解.podspec文件： 12345678910111213141516171819Pod::Spec.new do |s| s.name = "你的项目名" s.version = "项目的版本" s.summary = "项目的描述" s.homepage = "项目的主页，一般为github地址就行" s.license = "许可证：一般为 MIT" s.author = &#123; "作者名" =&gt; "你的邮箱" &#125; // 支持的最低版本，比如ios 8.0 s.platform = :ios, "8.0" // 源代码地址，也就是你github上的地址 s.source = &#123; :git =&gt; "你的github地址", :tag =&gt; "项目的tag" &#125; // 源代码的文件路径 s.source_files = "WCL", "WCL/**/*.&#123;h,m&#125;" , "WCL/*.&#123;swift&#125;" // 资源文件路径 s.resources = "WCL.png", "WCL/**/*.&#123;bundle&#125;" , "WCL/*.&#123;bundle&#125;" // 用到的框架 s.framework = "UIKit" // 依赖的第三方库 s.dependency "JSONKit", "~&gt; 1.4" 编辑完podspec文件后，需要验证一下这个文件是否可用，如果有任何WARNING或者ERROR都是不可以的，它就不能被添加到Spec Repo中，不过xcode的WARNING是可以存在的，验证需要执行命令： 1pod spec lint 你的podspec文件名.podspec 通过的话就验证成功，失败会告诉你错误的位置，一般很详细 五、传到CocoaPods上pod trunk push 命令会首先验证你本地的podspec文件(是否有错误)，之后会上传spec文件到trunk，最后会将你上传的podspec文件转换为需要的json文件。在工程根目录(包含有.podspec)下执行命令： 1pod trunk push 没有错误的话，会提示你成功，并返回一下类似代码： 12345678-------------------------------------------------------------------------------- 🎉 Congrats 🚀 CRRefresh (1.0.0) successfully published 📅 March 16th, 07:14 🌎 https://cocoapods.org/pods/CRRefresh 👍 Tell your friends!-------------------------------------------------------------------------------- 以上是基本流程，如果有什么问题欢迎交流，最后谢谢大家的阅读 作者 @W_C__L2017 年 03月 09日]]></content>
      <categories>
        <category>CocoaPods</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift设计模式学习 - 外观模式]]></title>
    <url>%2F2017%2F03%2F09%2Fswift%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[外观模式外观模式（Facade），为子系统中的一组接口提供一个一致的界面，定义一个高层接口，这个接口使得这一子系统更加容易使用。 外观模式的基本实现 上图是外观模式的UML图，下面是基本的代码实现过程： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//MARK: 外观类class Facade &#123; let one = SubSystemOne() let two = SubSystemTwo() let three = SubSystemThree() let four = SubSystemFour() public func methodA() &#123; print("方法组A") one.methodOne() two.methodTwo() three.methodThree() &#125; public func methodB() &#123; print("方法组B") two.methodTwo() three.methodThree() four.methodFour() &#125;&#125;//MARK: 子系统类class SubSystemOne &#123; public func methodOne() &#123; print("子系统方法一") &#125;&#125;class SubSystemTwo &#123; public func methodTwo() &#123; print("子系统方法二") &#125;&#125;class SubSystemThree &#123; public func methodThree() &#123; print("子系统方法三") &#125;&#125;class SubSystemFour &#123; public func methodFour() &#123; print("子系统方法四") &#125;&#125; 外观模式解决实际问题（购买基金）在生活中很多地方也用到外观模式，比如购买基金，我们从基金机构那里购买基金，然后他们帮我们管理我们的基金，去操作和运行，我们只管购买和卖出就行了，而不用去管他们内部的操作，下面是UML图和具体实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/// 基金类class Fund &#123; var gu1 = Stock1() var gu2 = Stock2() var gu3 = Stock3() var nd = NationalDebt() var rt = Realty() public func buyFund() &#123; print("买入基金") gu1.buy() gu2.buy() gu3.buy() nd.buy() rt.buy() &#125; public func shellFund() &#123; print("\n卖出基金") gu1.shell() gu2.shell() gu3.shell() nd.shell() rt.shell() &#125;&#125;//股票类class Stock1: Deal &#123; var dealName: String &#123; return "股票一" &#125;&#125;class Stock2: Deal &#123; var dealName: String &#123; return "股票二" &#125;&#125;class Stock3: Deal &#123; var dealName: String &#123; return "股票三" &#125;&#125;class NationalDebt: Deal &#123; var dealName: String &#123; return "国债" &#125;&#125;class Realty: Deal &#123; var dealName: String &#123; return "房地产" &#125;&#125;protocol Deal &#123; var dealName: String &#123;get&#125; mutating func shell() mutating func buy()&#125;extension Deal &#123; mutating func shell() &#123; print("\(dealName)卖出") &#125; mutating func buy() &#123; print("\(dealName)买入") &#125;&#125; 下面我们调用一下代码： 12345let jijin = Fund()// 基金购买jijin.buyFund()// 基金赎回jijin.shellFund() 下面是调用的结果： 12345678910111213买入基金股票一买入股票二买入股票三买入国债买入房地产买入卖出基金股票一卖出股票二卖出股票三卖出国债卖出房地产卖出 以上就是简单的外观模式的实现，定义高层接口，基金的买入和卖出，去使用整个基金系统，而不用去管内部是怎么操作的。 外观模式的优点（1）实现了子系统与客户端之间的松耦合关系。 （2）客户端屏蔽了子系统组件，减少了客户端所需处理的对象数目，并使得子系统使用起来更加容易。 作者 @W_C__L2017 年 03月 09日]]></content>
      <categories>
        <category>swift设计模式学习</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift设计模式学习 - 模板方法模式]]></title>
    <url>%2F2017%2F02%2F24%2Fswift%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[模板方法模式模板方法模式，定义一个操作中算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 模板方法模式的基本实现 上图是基本模板模式的UML图，这种设计模式在很多地方都有用到，下面是基本实现的代码： 1234567891011121314151617181920212223242526272829class AbstractClass &#123; func primitiveOperation1() &#123;&#125; func primitiveOperation2() &#123;&#125; func templateMethod() &#123; primitiveOperation1() primitiveOperation2() &#125;&#125;class ConcreteClassA: AbstractClass &#123; override func primitiveOperation1() &#123; print("具体类A方法1实现") &#125; override func primitiveOperation2() &#123; print("具体类A方法2实现") &#125;&#125;class ConcreteClassB: AbstractClass &#123; override func primitiveOperation1() &#123; print("具体类B方法1实现") &#125; override func primitiveOperation2() &#123; print("具体类B方法2实现") &#125;&#125; 模板方法模式解决实际问题（填表格）在生活中很多地方用到的模板方法模式，比如我们填一份表格，我们要按照表格的模板开始填，只需要填关键部分，而不用将表格的所有文字炒一遍，下面是UML和代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 表格的模板class TemplateTable &#123; func showTable() &#123; fillName() fillSex() &#125; func fillName() &#123; print("你的名字：\(yourName())") &#125; func fillSex() &#123; print("你的性别：\(yourSex())") &#125; func yourName() -&gt; String &#123; return "" &#125; func yourSex() -&gt; String &#123; return "" &#125;&#125;// wcl填写的表格class WCLTable: TemplateTable &#123; override func yourName() -&gt; String &#123; return "wcl" &#125; override func yourSex() -&gt; String &#123; return "male" &#125;&#125;// scy填写的表格class SCYTable: TemplateTable &#123; override func yourName() -&gt; String &#123; return "scy" &#125; override func yourSex() -&gt; String &#123; return "female" &#125;&#125; 下面我们调用一下代码： 1234let wcl = WCLTable()wcl.showTable()let scy = SCYTable()scy.showTable() 下面是调用的结果： 1234你的名字：wcl你的性别：male你的名字：scy你的性别：female 模板方法模式的特点模板方法模式是通过把不变行为搬移到超类，去除子类中重复代码来体现它的优势，它提供了一个很好的代码复用平台。 以上是我对模板方法模式的理解，如果有不对的地方欢迎大家交流，最后谢谢大家的阅读~~ 作者 @W_C__L2017 年 02月 24日]]></content>
      <categories>
        <category>swift设计模式学习</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift设计模式学习 - 代理模式]]></title>
    <url>%2F2017%2F02%2F21%2Fswift%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式学习的demo地址，欢迎大家学习交流 代理模式代理模式为其他对象提供一种代理以控制对这个对象的访问，在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。 代理模式的组成 抽象角色：通过接口或抽象类声明真实角色实现的业务方法。 代理角色：实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。 真实角色：实现抽象角色，定义真实角色所要实现的业务逻辑，供代理角色调用。 代理模式的基本实现 上图是最基本的代理模式的结构图，下面将用Swift代码来实现一个基本代理模式： 1234567891011121314151617181920// 定义一个接口protocol Subject &#123; func request()&#125;class RealSubject: Subject &#123; func request() &#123; print("真实的请求") &#125;&#125;class Proxy: Subject &#123; // 真实的对象 var realSubject: RealSubject? func request() &#123; realSubject?.request() &#125;&#125; 以上是一个最基本的代理模式的构成，这样可以用Proxy来代替RealSubject，从而对客户端隐藏真实的对象。 代理模式解决实际问题（快递于淘宝卖家的关系）在生活中很多地方存在着代理模式，比如淘宝卖家与快递的问题，我们买东西需要淘宝卖家进行配送，但是其实他们并没有配送的功能，实际上是由快递公司进行的配送，淘宝就相当于快递公司的代理，买家也不用关心淘宝卖家是怎么送货过来的，下面是大概的实现方式： 1234567891011121314151617181920212223242526272829303132333435// 定义一个配送的接口protocol Deliver &#123; var goodsName: String &#123; get &#125; func deliverGoods()&#125;// 快递公司继承配送的接口class Express: Deliver &#123; var goodsName: String init(goodsName: String) &#123; self.goodsName = goodsName &#125; func deliverGoods() &#123; print("由顺丰快递配送\(goodsName)") &#125;&#125;// 淘宝卖家也继承配送的接口class Taobao: Deliver &#123; // 实际上是由快递公司配送 var express: Express var goodsName: String init(goodsName: String) &#123; express = Express(goodsName: goodsName) self.goodsName = goodsName print("买了一个\(goodsName)") &#125; func deliverGoods() &#123; express.deliverGoods() &#125;&#125; 下面我们使用一下以上代码看看： 12let tb = Taobao(goodsName: "电脑")tb.deliverGoods() 下面是打印结果： 12买了一个电脑由顺丰快递配送电脑 代理模式的优点 职责清晰，真实的角色就是实现实际的业务逻辑，不用关心其他非本职责的事务，通过后期的代理完成一件完成事务，附带的结果就是编程简洁清晰。 代理对象可以在客户端和目标对象之间起到中介的作用，这样起到了中介的作用和保护了目标对象的作用。 高扩展性 以上是我对于代理模式的理解，如果有不对的地方欢迎大家交流，最后谢谢大家的阅读~~ 作者 @W_C__L2017 年 02月 21日]]></content>
      <categories>
        <category>swift设计模式学习</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift设计模式学习 - 原型模式]]></title>
    <url>%2F2017%2F02%2F20%2Fswift%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式学习的demo地址，欢迎大家学习交流 原型模式用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 定义用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。Prototype原型模式是一种创建型设计模式，Prototype模式允许一个对象再创建另外一个可定制的对象，根本无需知道任何如何创建的细节,工作原理是:通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建。它主要面对的问题是：“某些结构复杂的对象”的创建工作；由于需求的变化，这些对象经常面临着剧烈的变化，但是他们却拥有比较稳定一致的接口。 原型模式的基本实现 上图是最基本的原型模式的结构图，下面将用Swift代码来实现一个基本原型模式： 12345678910111213141516// 定义一个原型协议protocol Prototype &#123; var id: String &#123; get &#125; func clone() -&gt; Prototype&#125;// 原型的具体对象class ConcretePrototypeA: Prototype &#123; var id: String = "" // 实现克隆的具体操作 func clone() -&gt; Prototype &#123; let p = ConcretePrototypeA() p.id = id return p &#125;&#125; 不知道大家有没哟发现，这个设计模式我们在代码中经常会用到，那就是NSCopying协议，通过这个协议来实现对象的深拷贝，下面我们就用NSCopying来实现一下。 原型模式解决实际问题（NSCopying）123456789101112131415161718192021222324import Foundationclass Resume: NSCopying &#123; var name: String var sex: String var age: String var company: String init(name: String, sex: String, age: String, company: String) &#123; self.name = name self.sex = sex self.age = age self.company = company &#125; func disPlay() &#123; print("name: \(name), sex: \(sex), age: \(age), company: \(company)") &#125; func copy(with zone: NSZone? = nil) -&gt; Any &#123; return Resume(name: name, sex: sex, age: age, company: company) &#125;&#125; 上面是通过NSCopying来实现原型模式的例子，一下是使用过程： 123456let wcl = Resume(name: "wcl", sex: "male", age: "23", company: "beijing")let scy = wcl.copy() as! Resumescy.name = "scy"scy.sex = "female"wcl.disPlay()scy.disPlay() 以下是打印的结果: 12name: wcl, sex: male, age: 23, company: beijingname: scy, sex: female, age: 23, company: beijing 以上是我对于原型模式的理解，如果有不对的地方欢迎大家交流，最后谢谢大家的阅读~~ 作者 @W_C__L2017 年 02月 20日]]></content>
      <categories>
        <category>swift设计模式学习</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift设计模式学习 - 策略模式]]></title>
    <url>%2F2017%2F02%2F18%2Fswift%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[策略模式策略模式定义了算法家族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化，不会影响到使用算法的客户。 策略模式的组成 抽象策略角色（Strategy）： 策略类，通常由一个接口或者抽象类实现。 具体策略角色（ConcreteStrategy）：包装了相关的算法和行为。 环境角色（Context）：持有一个策略类的引用，最终给客户端调用。 策略模式的基本实现 上图是最基本的装饰模式的结构图，下面将用Swift代码来实现一个基本策略模式： 12345678910111213141516171819202122232425262728293031// 策略类，定义所有支持 的算法的公共接口protocol Strategy &#123; func AlgorithmInterface()&#125;// 具体策略类，封装了具体的算法或行为，继承于Strategyclass ConcreteStrategyA: Strategy &#123; func AlgorithmInterface() &#123; print("ConcreteStrategyA") &#125;&#125;class ConcreteStrategyB: Strategy &#123; func AlgorithmInterface() &#123; print("ConcreteStrategyB") &#125;&#125;class ConcreteStrategyC: Strategy &#123; func AlgorithmInterface() &#123; print("ConcreteStrategyC") &#125;&#125;// Context上下文，用一个 ConcreteStrategy来配置，维护一个对Strategy对象的引用class Context &#123; var strategy: Strategy? func ContextInterface() &#123; strategy?.AlgorithmInterface() &#125;&#125; 以上代码是最简单的策略模式的实现过程，定义了一个Strategy的算法族，通过它的子类可以实现算法（AlgorithmInterface）的替换，而不会影响到客户端。 用策略模式解决实际问题（商场打折）我们知道在商场中一般有很多打折优惠方案，类似这种问题就可以用策略模式来解决，打折不同的方案就相当于不同的策略（ConcreteStrategy），然后用一个Context类来实现不同算法的切换，下面是商场打折策略模式的实现于UML图： 以上是一个简单的商场收银系统，CashNormal为普通收费子类，CashRebate为打折收费子类，CashReturn为返利收费子类，下面是代码的实现过程： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import Foundation// 定义一个收费的策略接口protocol CashSuper &#123; func acceptCash(money: Double) -&gt; Double&#125;// 普通收费子类class CashNormal: CashSuper &#123; // 正常原价返回 func acceptCash(money: Double) -&gt; Double &#123; return money &#125;&#125;// 打折收费子类class CashRebate: CashSuper &#123; // 折扣率 private var moneyRebate: Double = 1.0 init(moneyRebate: Double) &#123; self.moneyRebate = moneyRebate &#125; func acceptCash(money: Double) -&gt; Double &#123; return money*moneyRebate &#125;&#125;// 返利收费子类class CashReturn: CashSuper &#123; // 返利要求 private var moneyCondition: Double = 0 // 返多少 private var moneyReturn: Double = 0 init(moneyCondition: Double, moneyReturn: Double) &#123; self.moneyCondition = moneyCondition self.moneyReturn = moneyReturn &#125; func acceptCash(money: Double) -&gt; Double &#123; var result = money if money &gt;= moneyCondition &#123; result = money - floor(money / moneyCondition) * moneyReturn &#125; return result &#125;&#125;// context类class CashContext &#123; private var cs: CashSuper? // 通过枚举判断使用哪种方式 init(style: CashStyle) &#123; switch style &#123; case .normal: cs = CashNormal() case .rebate(moneyRebate: let money): cs = CashRebate(moneyRebate: money) case .return(moneyCondition: let moneyCondition, moneyReturn: let moneyReturn): cs = CashReturn(moneyCondition: moneyCondition, moneyReturn: moneyReturn) &#125; &#125; func getResult(money: Double) -&gt; Double &#123; return cs?.acceptCash(money: money) ?? 0 &#125;&#125;// 优惠的枚举类型enum CashStyle &#123; case normal case rebate(moneyRebate: Double) case `return`(moneyCondition: Double, moneyReturn: Double)&#125; 下面我们测试一下代码： 12345678910let money: Double = 300// 普通let normal = CashContext(style: .normal)// 打7折let rebate = CashContext(style: .rebate(moneyRebate: 0.7))// 满一百返20let `return` = CashContext(style: .return(moneyCondition: 100, moneyReturn: 20))print("普通: \(normal.getResult(money: money))")print("打8折: \(rebate.getResult(money: money))")print("满一百返20: \(`return`.getResult(money: money))") 下面是执行的结果： 123普通: 300.0打8折: 210.0满一百返20: 240.0 策略模式总结我们可以理解为策略就是用来封装算法，但在实践过程中不用那么死板，可以用来封装几乎任何类型的规则，只要在分析过程中听到需要在不同时间应用不同的业务规则，就可以考虑使用策略模式处理这种变化的可能性。 以上是我对于策略模式的理解，如果有不对的地方欢迎大家交流，最后谢谢大家的阅读~~ 作者 @W_C__L2017 年 02月 18日]]></content>
      <categories>
        <category>swift设计模式学习</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS动画进阶 - 手摸手教你写ShineButton动画]]></title>
    <url>%2F2017%2F02%2F16%2FiOS%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6-%E6%89%8B%E6%91%B8%E6%89%8B%E6%95%99%E4%BD%A0%E5%86%99ShineButton%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[前段时间在github上看见一个非常nice的动画效果，可惜是安卓的，想着用swift写一个iOS版的，下下来源代码研究了一下，下面是我写代码的心路历程 先上图和demo的地址 分析动画过程刚开始看的时候感觉这个动画很炫酷，实现起来应该挺复制的，后来我将gif图逐一分解，大致浏览了一下安卓的实现过程，大致了解的实现的过程，下面是一些关键的动画步骤： 第一步是里面图片的缩放动画，使用CALayer配合CAKeyframeAnimation来实现； 第二步是是里面一个圆环逐渐变大的过程，使用CAShapeLayer配合CAKeyframeAnimation来实现； 第三步是最外面一层太阳的扩散效果同样也使用CAShapeLayer配合CAKeyframeAnimation来实现； 最后是闪烁和颜色变化的的效果，使用CABasicAnimation和CADisplayLink来实现。 一、缩放动画的实现这个实现的过程相对而言比较简单，用CALayer做为mask来实现下图心形的图片，然后用CAKeyframeAnimation来实现动画，values的值为[0.4, 1, 0.9, 1]，差值器模式为kCAAnimationCubic，下面是实现结果和关键代码： 1234567public func startAnim() &#123; let anim = CAKeyframeAnimation(keyPath: "transform.scale") anim.duration = animDuration anim.values = [0.4, 1, 0.9, 1] anim.calculationMode = kCAAnimationCubic maskLayer.add(anim, forKey: "scale")&#125; 二、圆环扩散动画的实现首先圆环我们用CAShapeLayer来绘制一个圆环，然后通过CAKeyframeAnimation来改变圆环的path就可以了，下面是实现结果和关键代码： 12345678910111213public func startAnim() &#123; let anim = CAKeyframeAnimation(keyPath: "path") anim.duration = params.animDuration * 0.1 let size = frame.size let fromPath = UIBezierPath(arcCenter: CGPoint.init(x: size.width/2, y: size.height/2), radius: 1, startAngle: 0, endAngle: CGFloat(M_PI) * 2.0, clockwise: false).cgPath let toPath = UIBezierPath(arcCenter: CGPoint.init(x: size.width/2, y: size.height/2), radius: size.width/2 * CGFloat(params.shineDistanceMultiple), startAngle: 0, endAngle: CGFloat(M_PI) * 2.0, clockwise: false).cgPath anim.delegate = self anim.values = [fromPath, toPath] anim.timingFunctions = [CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseOut)] anim.isRemovedOnCompletion = false anim.fillMode = kCAFillModeForwards shapeLayer.add(anim, forKey: "path")&#125; 三、太阳的扩散效果实现首先我们得先算出每个太阳的位置和将要扩散到的位置，然后用CAShapeLayer绘制出太阳，用CAKeyframeAnimation实现扩散的效果，下面是实现后的结果和关键代码 : 123456789101112131415161718192021222324252627public func startAnim() &#123; let radius = frame.size.width/2 * CGFloat(params.shineDistanceMultiple*1.4) var startAngle: CGFloat = 0 let angle = CGFloat(M_PI*2/Double(params.shineCount)) + startAngle if params.shineCount%2 != 0 &#123; startAngle = CGFloat(M_PI*2 - (Double(angle)/Double(params.shineCount))) &#125; for i in 0..&lt;params.shineCount &#123; let bigShine = shineLayers[i] let bigAnim = getAngleAnim(shine: bigShine, angle: startAngle + CGFloat(angle)*CGFloat(i), radius: radius) let smallShine = smallShineLayers[i] var radiusSub = frame.size.width*0.15*0.66 if params.shineSize != 0 &#123; radiusSub = params.shineSize*0.66 &#125; let smallAnim = getAngleAnim(shine: smallShine, angle: startAngle + CGFloat(angle)*CGFloat(i) - CGFloat(params.smallShineOffsetAngle)*CGFloat(M_PI)/180, radius: radius-radiusSub) bigShine.add(bigAnim, forKey: "path") smallShine.add(smallAnim, forKey: "path") &#125; let angleAnim = CABasicAnimation(keyPath: "transform.rotation") angleAnim.duration = params.animDuration * 0.87 angleAnim.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionLinear) angleAnim.fromValue = 0 angleAnim.toValue = CGFloat(params.shineTurnAngle)*CGFloat(M_PI)/180 angleAnim.delegate = self add(angleAnim, forKey: "rotate")&#125; 四、最后再将这些动画通过一定规律结合起来 上图是将之前动画步骤组合起来后的效果，上面的一些代码只是部分代码，全部代码可以去我的github地址上去下在浏览，如果大家喜欢可以点一个赞，有更好的想法也可以提出来，大家一起交流一下，最后谢谢大家阅读~~ 作者 @W_C__L2017 年 02月16日]]></content>
      <categories>
        <category>iOS动画进阶</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift设计模式学习 - 装饰模式]]></title>
    <url>%2F2017%2F02%2F09%2Fswift%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[装饰模式在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。 装饰模式的特点 装饰对象和真实对象有相同的接口。这样客户端对象就能以和真实对象相同的方式和装饰对象交互。 装饰对象包含一个真实对象的引用（reference） 装饰对象接受所有来自客户端的请求。它把这些请求转发给真实的对象。 装饰对象可以在转发这些请求以前或以后增加一些附加功能。这样就确保了在运行时，不用修改给定对象的结构就可以在外部增加附加的功能。在面向对象的设计中，通常是通过继承来实现对给定类的功能扩展。 装饰模式的基本实现 上图是最基本的装饰模式的结构图，下面将用swift代码来实现一个基本装饰模式： 1）.先写一个Component接口 123protocol Component &#123; func operation()&#125; 2）.写一个具体的Component对象 12345class ConcreteComponent: Component &#123; func operation() &#123; // 具体操作的实现 &#125;&#125; 3）.写一个装饰抽象类 123456class Decorator: Component &#123; var component: Component? func operation() &#123; component?.operation() &#125;&#125; 4）.写具体的装饰对象 123456789101112131415161718192021// 装饰对象Aclass ConcreteDecoratorA: Decorator &#123; private var addedState: String? override func operation() &#123; super.operation() addedState = "ConcreteDecoratorA独有的功能，用来区分ConcreteDecoratorB" // 具体装饰对象A的操作 &#125;&#125;// 装饰对象Bclass ConcreteDecoratorB: Decorator &#123; override func operation() &#123; super.operation() addedBehavior() // 具体装饰对象B的操作 &#125; // ConcreteDecoratorB独有的方法，用来区分ConcreteDecoratorA private func addedBehavior() &#123; &#125;&#125; 通过以上代码我们就能简单了解装饰模式的基本实现于过程，它的主要的目的就是：在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能，就像以上示例代码一样，通过ConcreteDecoratorA与ConcreteDecoratorB去扩展ConcreteComponent这个对象的功能，这样不用去改变ConcreteComponent这个类的源文件，也可以达到扩展的效果。 用装饰模式解决实际问题（买车选配的问题）下面通过一个实际的例子来看看，比如我们在买车的时候一般会选配很多配件，下面我们通过策略模式来实现这一过程，下上个结构图： 下面贴上代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// Componentprotocol Car &#123; // 多少钱 func howMuch()-&gt; Int // 展示装配的配件 func showParts()&#125;// ConcreteComponentsclass Suv: Car &#123; init(owner: String) &#123; print("\(owner)买了一辆Suv，10W") &#125; func howMuch() -&gt; Int &#123; return 10 &#125; func showParts() &#123;&#125;&#125;class Mpv: Car &#123; init(owner: String) &#123; print("\(owner)买了一辆Mpv，15W") &#125; func howMuch() -&gt; Int &#123; return 15 &#125; func showParts() &#123;&#125;&#125;// Decoratorclass CarParts: Car &#123; var car: Car? func howMuch() -&gt; Int &#123; return car?.howMuch() ?? 0 &#125; func showParts() &#123; car?.showParts() &#125; func decorator(_ car: Car) -&gt; Car &#123; self.car = car return self &#125;&#125;// ConcreteDecorators class Sofa: CarParts &#123; override func howMuch() -&gt; Int &#123; return super.howMuch() + 1 &#125; override func showParts() &#123; super.showParts() print("选配了真皮沙发，1W") &#125;&#125;class Safety: CarParts &#123; override func howMuch() -&gt; Int &#123; return super.howMuch() + 3 &#125; override func showParts() &#123; super.showParts() print("选配了全套安全系统，3W") &#125;&#125;class Engine: CarParts &#123; override func howMuch() -&gt; Int &#123; return super.howMuch() + 5 &#125; override func showParts() &#123; super.showParts() print("选配了V8发动机，5W") &#125;&#125; 下面我们使用一下以上代码看看： 12345678910111213141516171819//wcl买一辆suvvar suv: Car = Suv(owner: "wcl")//装配沙发suv = Sofa().decorator(suv)//装配发动机suv = Engine().decorator(suv)//装配安全系统suv = Safety().decorator(suv)suv.showParts()print("一共花了\(suv.howMuch())W")print("\n")//wcl买一辆mpvvar mpv: Car = Mpv(owner: "wcl")//装配发动机mpv = Engine().decorator(mpv)//装配安全系统mpv = Safety().decorator(mpv)mpv.showParts()print("一共花了\(mpv.howMuch())W") 以下是代码打印的结果： 12345678910wcl买了一辆Suv，10W选配了真皮沙发，1W选配了V8发动机，5W选配了全套安全系统，3W一共花了19Wwcl买了一辆Mpv，15W选配了V8发动机，5W选配了全套安全系统，3W一共花了23W 这样就用装饰模式简单了实现了一下这个过程，在不改变Suv于Mpv这两个类的源文件的情况下对它进行操作。 总结我们先看看装饰模式的优点： 可以将类中装饰功能从类中搬出移除，这样可以简化原有的类 有效的将核心职责和装饰功能区分开来，而且可以除去相关类中重复的装饰逻辑 装饰模式的缺点： 装饰模式虽然扩展性较高，类的数量略多，如何取舍可扩展性和简洁性是个问题，有所选择就要有所牺牲 很难搞清楚一个类究竟被装饰了多少层，可能是1层，也可能是100层 以上是我对于策略模式的理解，如果有不对的地方欢迎大家交流，最后谢谢大家的阅读~~ 作者 @W_C__L2017 年 02月 09日]]></content>
      <categories>
        <category>swift设计模式学习</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发进阶 - Photos详解基于Photos的图片选择器]]></title>
    <url>%2F2017%2F01%2F11%2FiOS%E5%BC%80%E5%8F%91%E8%BF%9B%E9%98%B6-Photos%E8%AF%A6%E8%A7%A3%E5%9F%BA%E4%BA%8EPhotos%E7%9A%84%E5%9B%BE%E7%89%87%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[很早之前就用OC把代码写完了并用在项目中了，一直没时间整理，现在用swift重写一份，并且更加详细的来了解这个Photos框架，下面是我集合苹果官方文档和其他大神的博客写出的一篇关于Photos框架的介绍 老规矩先上效果图和Demo地址： 了解Photos框架Photos是ios8出的一个新的图片选择框架，取代之前的AssetsLibrary框架，相比较AssetsLibrary框架Photos的用法更加灵活，发现在iOS9中AssetsLibrary已经被弃用了，并且也不支持livePhoto，iOS9上再使用AssetsLibrary框架时还有个严重的问题就是图片分辨率会变的很低，这篇文章主要讲解一下Photos的简单用法，用它做一个简单的图片选择器。 Photos中各个类的简单解释： 类名 作用 PHAdjustmentData 当用户编辑资源，照片与修改后的图像或视频数据保存在一个PHAdjustmentData对象中 PHAsset 代表照片库中的一个资源实体，可以理解为一张照片，在打印的时候，可以清楚的看见里面包含了照片的时间、标题等信息 PHAssetChangeRequest 使用PHAssetChangeRequest对象来创建、删除和修改相片库里面的PHAsset对象 PHAssetCollectionChangeRequest 使用PHAssetCollectionChangeRequest对象来创建、删除和修改相片库里面的PHAssetCollection对象 PHAssetCreationRequest 使用PHAssetCreationRequest对象构造一个新的照片或视频，并将其添加到照片库 PHAssetResource 一个PHAssetResource对象表示在照片库中的照片或视频资源（也就是一个PHAsset对象）相关联的基础数据资源之一，使用PHAssetResourceManager类获取它 PHAssetResourceManager PHAssetResourceManager对象提供了访问与照片资源相关的资源基础数据存储方法 PHChange PHChange对象来通知的照片库中的资源的一些变法，比如增加和删除 PHCollection PHAssetCollection对象表示一组照片或视频资源。包括时刻和相册中可见照片应用,以及特殊的集合,如共享照片流。 PHCollectionListChangeRequest 使用PHCollectionListChangeRequest对象在一个照片库中创建、删除或修改PHCollectionList对象。 PHContentEditingInput PHContentEditingInput对象描述资产用于编辑元数据 PHContentEditingOutput PHContentEditingOutput对象表示编辑照片资产的照片或视频内容的结果 PHFetchOptions 获取资源时的检索参数，可以传 nil，即使用系统默认值 PHFetchResult 通过PHFetchResult来获取照片实体的有序列表 PHImageManager PHImageManager对象提供用于加载与PHAsset对象相关联的图像或视频数据的方法。使用这些方法来获取全尺寸照片资产或缩略图，或者检索AV Foundation对象播放，导出和操纵的视频资产。 PHLivePhoto 用来获取LivePhoto实体 PHObject 照片等实体的抽象类 PHPhotoLibrary PHPhotoLibrary对象表示用户的照片库整套资源和收藏的照片，包括存储在本地设备上在iCloud的照片对象。 PhotosTypes 与Photos框架相关的类型的枚举 获取相册列表获取相册列表可以需要用到一下类： PHFetchOptions：对象检索的对象，可以对相册列表进行筛选 PHAssetCollection：图片集合的对象，筛选后获得的集合 下面是获取相册列表的代码片段： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 //MARK: 属性列表 //全部相册的数组 private(set) var photoAlbums = [[String: PHFetchResult&lt;PHAsset&gt;]]() private(set) var selectPhotoArr = [PHAsset]() //是否同步请求图片 public var isSynchronous: Bool = false &#123; didSet&#123; self.photoOption.isSynchronous = isSynchronous &#125; &#125;//MARK: 初始化方法 override init() &#123; super.init() //图片请求设置成快速获取 self.photoOption.resizeMode = .fast self.photoOption.deliveryMode = .opportunistic getPhotoAlbum() &#125; /** 开始获取获取相册列表 */ private func getPhotoAlbum() &#123; //创建一个PHFetchOptions对象检索照片 let options = PHFetchOptions() //通过创建时间来检索 options.sortDescriptors = [NSSortDescriptor.init(key: photoCreationDate, ascending: false)] //通过数据类型来检索，这里为只检索照片 options.predicate = NSPredicate.init(format: "mediaType in %@", [PHAssetMediaType.image.rawValue]) //通过检索条件检索出符合检索条件的所有数据，也就是所有的照片 let allResult = PHAsset.fetchAssets(with: options) //获取用户创建的相册 let userResult = PHAssetCollection.fetchTopLevelUserCollections(with: nil) //获取智能相册 let smartResult = PHAssetCollection.fetchAssetCollections(with: .smartAlbum, subtype: .albumRegular, options: nil) //将获取的相册加入到相册的数组中 photoAlbums.append([WCLImagePickerBundle.localizedString(key: "全部照片"): allResult]) userResult.enumerateObjects(options: .concurrent) &#123; (collection, index, stop) in let assetcollection = collection as! PHAssetCollection //通过检索条件从assetcollection中检索出结果 let assetResult = PHAsset.fetchAssets(in: assetcollection, options: options) if assetResult.count != 0 &#123; self.photoAlbums.append([assetcollection.localizedTitle!:assetResult]) &#125; &#125; smartResult.enumerateObjects(options: .concurrent) &#123; (collection, index, stop) in //通过检索条件从assetcollection中检索出结果 let assetResult = PHAsset.fetchAssets(in: collection, options: options) if assetResult.count != 0 &#123; self.photoAlbums.append([collection.localizedTitle!:assetResult]) &#125; &#125; &#125; 获取某个相册的所有图片列表需要用到的类： PHFetchResult：对象检索的对象，可以对图片进行筛选 PHAsset：图片资源的对象，代表一个图片或者视频资源 下面贴代码片段： 123456789101112131415/** 通过下标返回相册的PHFetchResult - parameter index: 选择相册的index - returns: 相册的PHFetchResult */public func getAblumResult(_ ablumIndex: Int) -&gt; PHFetchResult&lt;PHAsset&gt;? &#123; if let ablum = self.photoAlbums[wcl_safe: ablumIndex] &#123; if let result = ablum.values.first &#123; return result &#125; &#125; return nil&#125; 上面代码中返回的result就代表选中的相册的图片列表 获取到单张图片的数据通过上面获取到的相册的图片列表通过下标就能获得到图片对应的PHAsset，需要用到的类： PHCachingImageManager：获取图片数据的Manager，也可缓存数据 PHImageRequestOptions：获取图片的一些选项配置，比如获取方式等等 PHAsset：图片资源的对象，代表一个图片或者视频资源 下面是代码片段： 1234567891011121314151617181920212223/** 根据PHAsset获取photo - parameter ablumIndex: 相册的index - parameter alasset: 相册里图片的PHAsset - parameter photoSize: 图片的size - parameter resultHandler: 返回照片的回调 */public func getPhoto(_ photoSize: CGSize, alasset: PHAsset?, resultHandler: ((UIImage?, [AnyHashable: Any]?) -&gt; Void)?) &#123; if alasset != nil &#123; let scale = UIScreen.main.scale let photoScaleSize = CGSize(width: photoSize.width*scale, height: photoSize.height*scale) self.photoManage.requestImage(for: alasset!, targetSize: photoScaleSize, contentMode: .aspectFill, options: self.photoOption, resultHandler: &#123; (image, infoDic) in if image != nil &#123; resultHandler?(image, infoDic) &#125;else &#123; //没获取到返回默认图片 let image_buffer = WCLImagePickerBundle.imageFromBundle("image-buffer") resultHandler?(image_buffer, infoDic) &#125; &#125;) &#125;&#125; 将图片存入相册有时候我们需要将应用里的图片存到相册里面，一下是会用到的类： PHPhotoLibrary：代表我们手机中的图片库，用它来操作图片库中的图片 PHAssetChangeRequest：资源操作的请求类，用来对资源进行操作 代码片段： 1234567//执行变化PHPhotoLibrary.shared().performChanges(&#123; //创建一个图片资源 PHAssetChangeRequest.creationRequestForAsset(from: image) &#125;, completionHandler: &#123; (flag, error) in //执行结果回调 &#125;) 总结以上简单的讲解了一下Photos相关知识点和使用方法，更多的可以去官方文档上去查看。用Photos自己写了一个图片选择器，大家有兴趣的可以去看一下，有用的话可以star一下，写不不是很好，有什么错误可以指出来~最后谢谢大家的阅读。 作者 @W_C__L2017 年 01月 11日]]></content>
      <categories>
        <category>iOS开发进阶</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift学习笔记 - Range、ClosedRange、CountableClosedRange与CountableRange学习]]></title>
    <url>%2F2017%2F01%2F05%2Fswift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Range%E3%80%81ClosedRange%E3%80%81CountableClosedRange%E4%B8%8ECountableRange%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[在使用swift的过程中字符串操作的时候会用到Range，刚开始使用起来各种别扭，然后发现居然还有ClosedRange、CountableClosedRange和CountableRange，这下就彻底头疼了，下面简单的描述一下它们的区别 从命名来代码来理解和区分 CountableClosedRange：可数的闭区间 CountableRange：可数的开区间 ClosedRange：不可数的闭区间 Range：不可数的开居间 下面通过代码来理解一下： 1234567891011121314151617181920212223242526272829// 初始化测试：// CountableClosedRange: [0,2]let rangea = 0...2// CountableRange: [0,2)let rangeb = 0..&lt;2// ClosedRange: [0.1,2.1]let rangec = 0.1...2.1// Range: [0.1,2.1)let ranged = 0.1..&lt;2.1// for循环测试：可数的，可以for循环// CountableClosedRange：可数的可以for循环，输出0、1、2for i in rangea &#123; print(i)&#125;// CountableRange：可数的可以for循环，输出0、1for i in rangeb &#123; print(i)&#125;// for循环测试：不可数的，不能for循环// ClosedRange：不可数，不能for循环，以下写法会报错for i in rangec &#123; print(i)&#125;// Range：不可数，不能for循环，以下写法会报错for i in ranged &#123; print(i)&#125; 总结可以用可数和不可数、闭区间和开区间来理解记忆Range、ClosedRange、CountableClosedRange和CountableRange 可数：可以用于for循环 CountableClosedRange CountableRange 不可数：不能用于for循环 ClosedRange Range 闭区间： CountableClosedRange ClosedRange 开区间： Range CountableRange 以上是我总结的Range、ClosedRange、CountableClosedRange和CountableRange的区别，希望对大家有帮助，如果写的有错误希望大家能指出，谢谢大家的阅读 作者 @W_C__L2017 年 01月 05日]]></content>
      <categories>
        <category>swift学习笔记</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发进阶 - 自定义UICollectionViewLayout实现瀑布流布局]]></title>
    <url>%2F2016%2F12%2F21%2FiOS%E5%BC%80%E5%8F%91%E8%BF%9B%E9%98%B6-%E8%87%AA%E5%AE%9A%E4%B9%89UICollectionViewLayout%E5%AE%9E%E7%8E%B0%E7%80%91%E5%B8%83%E6%B5%81%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[最近项目中需要用到瀑布流的效果，但是用UICollectionViewFlowLayout又达不到效果，自己动手写了一个瀑布流的layout，下面是我的心路路程 先先上效果图与demo地址： 因为是用UICollectionView来实现瀑布流的，决定继承UICollectionViewLayout来自定义一个layout来实现一个简单瀑布流的布局，下面是需要重写的方法： 重写这个属性得出UICollectionView的ContentSize：collectionViewContentSize 重写这个方法来得到每个item的布局：layoutAttributesForItem(at indexPath: IndexPath) -&gt; UICollectionViewLayoutAttributes? 重写这个方法给UICollectionView所有item的布局：layoutAttributesForElements(in rect: CGRect) -&gt; [UICollectionViewLayoutAttributes]? 重写这个方法来实现UICollectionView前的操作：prepare() 实现思路通过代理模式获得到需要的列数和每一item的高度，用过列数与列之间的间隔和UICollectionView的宽度来得出每一列的宽度，item从左边到右布局，下一列的item放到高度最小的列下面，防止每列的高度不均匀，下面贴上代码和注释： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132import UIKit@objc protocol WCLWaterFallLayoutDelegate &#123; //waterFall的列数 func columnOfWaterFall(_ collectionView: UICollectionView) -&gt; Int //每个item的高度 func waterFall(_ collectionView: UICollectionView, layout waterFallLayout: WCLWaterFallLayout, heightForItemAt indexPath: IndexPath) -&gt; CGFloat&#125;class WCLWaterFallLayout: UICollectionViewLayout &#123; //代理 weak var delegate: WCLWaterFallLayoutDelegate? //行间距 @IBInspectable var lineSpacing: CGFloat = 0 //列间距 @IBInspectable var columnSpacing: CGFloat = 0 //section的top @IBInspectable var sectionTop: CGFloat = 0 &#123; willSet &#123; sectionInsets.top = newValue &#125; &#125; //section的Bottom @IBInspectable var sectionBottom: CGFloat = 0 &#123; willSet &#123; sectionInsets.bottom = newValue &#125; &#125; //section的left @IBInspectable var sectionLeft: CGFloat = 0 &#123; willSet &#123; sectionInsets.left = newValue &#125; &#125; //section的right @IBInspectable var sectionRight: CGFloat = 0 &#123; willSet &#123; sectionInsets.right = newValue &#125; &#125; //section的Insets @IBInspectable var sectionInsets: UIEdgeInsets = UIEdgeInsets.zero //每行对应的高度 private var columnHeights: [Int: CGFloat] = [Int: CGFloat]() private var attributes: [UICollectionViewLayoutAttributes] = [UICollectionViewLayoutAttributes]() //MARK: Initial Methods init(lineSpacing: CGFloat, columnSpacing: CGFloat, sectionInsets: UIEdgeInsets) &#123; super.init() self.lineSpacing = lineSpacing self.columnSpacing = columnSpacing self.sectionInsets = sectionInsets &#125; required init?(coder aDecoder: NSCoder) &#123; super.init(coder: aDecoder) &#125; //MARK: Public Methods //MARK: Override override var collectionViewContentSize: CGSize &#123; var maxHeight: CGFloat = 0 for height in columnHeights.values &#123; if height &gt; maxHeight &#123; maxHeight = height &#125; &#125; return CGSize.init(width: collectionView?.frame.width ?? 0, height: maxHeight + sectionInsets.bottom) &#125; override func prepare() &#123; super.prepare() guard collectionView != nil else &#123; return &#125; if let columnCount = delegate?.columnOfWaterFall(collectionView!) &#123; for i in 0..&lt;columnCount &#123; columnHeights[i] = sectionInsets.top &#125; &#125; let itemCount = collectionView!.numberOfItems(inSection: 0) attributes.removeAll() for i in 0..&lt;itemCount &#123; if let att = layoutAttributesForItem(at: IndexPath.init(row: i, section: 0)) &#123; attributes.append(att) &#125; &#125; &#125; override func layoutAttributesForItem(at indexPath: IndexPath) -&gt; UICollectionViewLayoutAttributes? &#123; if let collectionView = collectionView &#123; //根据indexPath获取item的attributes let att = UICollectionViewLayoutAttributes.init(forCellWith: indexPath) //获取collectionView的宽度 let width = collectionView.frame.width if let columnCount = delegate?.columnOfWaterFall(collectionView) &#123; guard columnCount &gt; 0 else &#123; return nil &#125; //item的宽度 = (collectionView的宽度 - 内边距与列间距) / 列数 let totalWidth = (width - sectionInsets.left - sectionInsets.right - (CGFloat(columnCount) - 1) * columnSpacing) let itemWidth = totalWidth / CGFloat(columnCount) //获取item的高度，由外界计算得到 let itemHeight = delegate?.waterFall(collectionView, layout: self, heightForItemAt: indexPath) ?? 0 //找出最短的那一列 var minIndex = 0 for column in columnHeights &#123; if column.value &lt; columnHeights[minIndex] ?? 0 &#123; minIndex = column.key &#125; &#125; //根据最短列的列数计算item的x值 let itemX = sectionInsets.left + (columnSpacing + itemWidth) * CGFloat(minIndex) //item的y值 = 最短列的最大y值 + 行间距 let itemY = (columnHeights[minIndex] ?? 0) + lineSpacing //设置attributes的frame att.frame = CGRect.init(x: itemX, y: itemY, width: itemWidth, height: itemHeight) //更新字典中的最大y值 columnHeights[minIndex] = att.frame.maxY &#125; return att &#125; return nil &#125; override func layoutAttributesForElements(in rect: CGRect) -&gt; [UICollectionViewLayoutAttributes]? &#123; return attributes &#125;&#125; 最后附带demo地址，大家喜欢的话可以star一下 上面是简单的瀑布流的实现过程，希望大家能学到东西，有很多地方考虑的不足，欢迎大家交流学习，谢谢大家的阅读~~ 作者 @W_C__L2016 年 12月 21日]]></content>
      <categories>
        <category>iOS开发进阶</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发进阶 - 富文本正则替换表情]]></title>
    <url>%2F2016%2F11%2F28%2FiOS%E5%BC%80%E5%8F%91%E8%BF%9B%E9%98%B6-%E5%AF%8C%E6%96%87%E6%9C%AC%E6%AD%A3%E5%88%99%E6%9B%BF%E6%8D%A2%E8%A1%A8%E6%83%85%2F</url>
    <content type="text"><![CDATA[最近写项目需要用到富文本解析字符串显示表情，下面是我使用正则替换实现富文本的方式，希望能帮助到大家 先上效果图和demo地址 实现过程中需要用到的知识点 NSRegularExpression（正则表达式） NSMutableAttributedString（用来显示富文本的string） 废话不多说，直接贴代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import UIKitstruct WCLEmojiParse &#123; //所有表情对应的字符串 static let emotions = ["[angry]", "[beers]", "[blush]", "[bomb]", "[cool]", "[flushed]", "[grin]", "[gun]", "[heart]", "[heartseyes]", "[imp]", "[Joy]", "[kiss]", "[ok]", "[persevere]", "[pray]", "[punch]", "[scream]", "[shit]", "[skull]", "[sleeping]", "[smiley]", "[smirk]", "[sob]","[sweat]", "[thumbsup]", "[tongue]", "[unamused]", "[v]", "[weary]", "[wink]", "[yum]"] //String的格式 static let textAttributes = [NSFontAttributeName: UIFont.systemFont(ofSize: 16), NSForegroundColorAttributeName: UIColor.black] //正则表达式的格式 static let pattern = "\\[+[a-z]+\\]" //表情的bounds static let attachmentBounds = CGRect.init(origin: CGPoint.init(x: 0, y: -5), size: CGSize.init(width: 24, height: 24)) //MARK: Public Methods static func replaceEmoji(_ str: String) -&gt; NSAttributedString &#123; //转成NSString let originalNSString = str as NSString //通过str获得NSMutableAttributedString let attStr = NSMutableAttributedString.init(string: str, attributes: textAttributes) var regex: NSRegularExpression? do &#123; regex = try NSRegularExpression.init(pattern: pattern, options: .caseInsensitive) &#125; catch let error as NSError &#123; print(error.localizedDescription) &#125; //获取到匹配正则的数据 if let matches = regex?.matches(in: str, options: .withoutAnchoringBounds, range: NSMakeRange(0,attStr.string.characters.count)) &#123; if matches.count &gt; 0 &#123; //遍历符合的数据进行解析 for i in 0..&lt;matches.count &#123; let result = matches[matches.count-i-1] let range = result.range let emojiStr = originalNSString.substring(with: range) //符合的数据是否为表情 if emotions.contains(emojiStr) &#123; if let image = UIImage.init(named: emojiStr) &#123; //创建一个NSTextAttachment let attachment = NSTextAttachment() attachment.image = image attachment.bounds = attachmentBounds //通过NSTextAttachment生成一个NSAttributedString let rep = NSAttributedString(attachment: attachment) //把表情于之前的字符串替换 attStr.replaceCharacters(in: range, with: rep) &#125; &#125; &#125; &#125; &#125; return attStr &#125;&#125; demo地址 以上是简单的富文本显示表情的方式，抛砖引玉，大家见笑了，希望大家能学到东西，谢谢大家的阅读 作者 @W_C__L2016 年 11月 28日]]></content>
      <categories>
        <category>iOS开发进阶</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发进阶 - 项目的本地化处理(多语言开发)]]></title>
    <url>%2F2016%2F11%2F21%2FiOS%E5%BC%80%E5%8F%91%E8%BF%9B%E9%98%B6-%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%9C%AC%E5%9C%B0%E5%8C%96%E5%A4%84%E7%90%86-%E5%A4%9A%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[最近项目本地化，需要支持11国语言，下面将本地化的步骤记录下来，方便查找使用，步骤很简单，有些地方也有坑，希望大家看后少走弯路~~ 什么是本地化本地化说直白点就是多语言开发，通过系统语言来判断应用使用的哪种语言，实现应用的本地化开发 本地化处理需要处理的文件 本地化应用程序的info.plist 本地化字符串处理（项目中所涉及的字符串） 本地化图片 XIB和storyboard的本地化处理 其他文件，比如csv等等 让我们的项目支持本地化首先我们只有设置成支持多语言了，我们才能在展示项目名称和项目中的字符串等将语言进行切换，具体操作如下图所示： 在如上图所示的地方添加你需要支持的语言就行了，我这里是添加了简体汉语和英语 如何判断当前系统使用的语言我们使用Locale这个类来判断当前的系统语言，方法： 12345678//获取当前的localelet locale = Locale.current//返回本地语言环境的语言代码,或者如果没有零//例如,对于地区“zh-Hant-HK”,返回“zh”let languageCode = locale.languageCode//返回该地区代码的语言环境,或者如果没有零//例如,对于地区“zh-Hant-HK”,返回“HK”let regionCode = locale.regionCode 同过以上的代码基本上能清楚的知道当前系统的使用的语言 获取系统支持的所有语言 同样我们也是通过Locale来获取系统支持的所有语言 123456//返回可用“语言环境”标识符的列表let availableList = Locale.availableIdentifiers//返回一个可用“语言环境”语言代码的列表let languageCodeList = Locale.isoLanguageCodes//返回一个可用“语言环境”地区代码的列表let languageCodeList = Locale.isoRegionCodes 如何本地化info.plist1.首先我们建一个名称叫InfoPlist.strings的本地化文件，记住名称必须叫InfoPlist.strings 2.选择让InfoPlist.strings支持的语言，如下图所示： 3.在InfoPlist.strings分别写入你想本地化的值，如下图所示 （格式如下所示，以分号结尾）： 如何获得info.plist中对应的Key我们可以通过打开info.plist的源码来获取到对于的Key值，如下图所示 ： 本地化字符串处理本地化字符串处理原理上跟infoPlist的处理差不多，只是我们需用配合一个方法来使用它： 1let str = NSLocalizedString("需要本地化的字符串", comment: "") 默认使用NSLocalizedString这个方法时我们是获取mainBundle中一个名字叫Localizable.strings的本地化文件，所以我们一般只需要建一个名字叫Localizable.strings的文件即可，方法步骤跟建立infoPlist.strings类似（传送门） 使用自定义的本地化文件使用自定义的本地化文件也很容易，也是之前的方法，我们只需要多填一些参数就可以了： 12//返回一个本地化的字符串，默认使用main bundle，如果没有指定一个public func NSLocalizedString(_ key: String, tableName: String? = default, bundle: Bundle = default, value: String = default, comment: String) -&gt; String 以上就是NSLocalizedString这个方法的所有参数，其中的tableName就是本地化文件的名称，默认就是Localizable.strings，自定义的话只需要建立一个新的，然后名称填你自己建立的本地化文件即可. XIB和storyboard的本地化处理XIB和storyboard的方法也很简单，跟本地放字符串类似，不过是本地化的XIB文件，如下图所示： XIB和storyboard的本地化又两种方式，如上图所示，一种是以本地化文件的方式实现，就是以.strings的本地化文件；另外一种是以XIB或storyboard的方式展示，具体如下图所示 ： 本地化图片和其他文件对于本地化图片和其他文件就比较费劲一点了，因为Xcode中图片并没有支持本地化，我们只有通过代码判断来决定使用相对于的本地化图片和文件了，判断方法的传送门 本地化中所遇到的问题在本地化中必须谨记一个问题，就是必须按本地化文件的格式来写入文件，因为本地化文件并不能检查出你分号后面是否多多余的字符串，造成的后果就是本地化文件失效！！ 借鉴了许多大神的博客，总结了一篇比较全的，希望大家能学到东西，又什么疑问可以留言，谢谢大家的阅读~ 作者 @W_C__L2016 年 11月 21日]]></content>
      <categories>
        <category>iOS开发进阶</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell学习小结 - 深入认识变量]]></title>
    <url>%2F2016%2F10%2F23%2FShell%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93-%E6%B7%B1%E5%85%A5%E8%AE%A4%E8%AF%86%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[变量的命名对于初学者来说，可以简单的理解为，变量就是保存在计算机内存中的一系列的键值对。 列如： 1str=&quot;hello&quot; 这里的str就是变量名，而hello就是变量的值 注意在shell中变量名的大小是敏感的，因此大小写不同的两个变量名并不代表同一个变量 变量的类型根据变量的类型确实，可以将程序设计语言分为两类，分别是静态类型语言和动态类型语言 静态类型语言： 是在编译期间就确定变量类型的语言，例如JAVA、C++、PASCAL，在这些语言中使用变量时，必须首先声明其类型。 动态设计语言： 实在程序执行过程中才确定变量的数据类型的语言。常见的有VBScript、PHP及Python。在这些语言中，变量的数据类型根据第一次赋给该变量的值的数据类型来确定。 根据变量是否强制要求类型定义，可以将程序设计语言分为强类型语言和弱类型语言 强类型语言： 要求用户在定义变量的时候必须明确指定其数据类型，例如JAVA和C++。在强类型语言中，数据类型之间的转换非常重要。 弱类型语言： 不要求用户明确指定变量的数据类型，例如VBScript。用户可以将任意类型的数值赋给该变量。并且，变量的数据类型之间的转换也无需明确进行。 Shell是一种动态类型语言和弱类型语言 变量的定义在Shell中。通常情况下用户可以直接使用变量，无需先进行定义，当用户第一次使用某个变量名时，实际上就同时定义了这个变量，在变量的作用域内，用户都可以使用该变量。如下所示： 123456#定义变量aa=1#定义变量bb=&quot;hello&quot;#定义变量cc=&quot;hello world&quot; 还可以通过declare关键字来定义变量，它可以对变量的读写属性和变量类型进行设置，改命令的基本语法： 1declare attribute variable 其中，attribute表示变量的属性，常用的属性如下所诉： 变量 说明 -p 显示所有变量的值 -i 将变量定义为整数。在之后就可以直接对表达式求值，结果只能是整数。如果求值失败或者不是整数，就设置为0 -r 将变量声明为只读变量。只读变量不允许修改，也不允许删除 -a 变量声明为数组变量。但这没必要。所有变量都不必显式定义就可以用做数组，事实上，在某种意义上，所有变量都是数组，而且赋值给没有下标的变量与赋值给下标为0的数组元素相同。 -f 显示所有自定义函数，包括名称和函数体 -x 将变量设置成环境变量，这样在随后的脚本和程序中可以使用 变量与引号在Shell语言中一共有3种引号，分别为单引号（’ ‘）、双引号（” “）和反引号（``），它们的作用是不同。 单引号： 括起来的字符都做为普通字符出现 双引号： 除”$”、”\”、” &quot;和&quot; &quot; &quot;这几个字符仍是特殊符并保留其特殊功能外，其余字符仍然做为普通字符对待 反引号： 括起来的字符串被Shell解释为命令，在执行时，Shell 首先执行改命令，并以它的标准输出结果取代整个反引号（包括两个反引号）部分 反引号的用法： 12#输出当前目录echo &quot;current directory is `pwd`&quot; 变量的作用域Shell跟其他语言一样，作用域分为全局变量和局部变量。 全局变量通常认为，全局变量是使用范围较大的变量，不局限某个局部使用。如下： 1234567891011121314#定义函数func()&#123; #输出变量的值 echo &quot;$v1&quot; #修改变量的值 v1=200&#125;#在脚本中定义变量v1=100#调用函数func#输出变量的值echo &quot;$v1&quot; 该执行的结果如下： 12100200 在函数内部定义变量，代码如下： 12345678910#定义函数func() &#123; #在函数内部定义变量 v2=200&#125;#调用函数func#输出变量的值echo &quot;$v2&quot; 该执行的结果如下： 1200 局部变量与全局变量想比，局部变量的使用范围较小，通常仅限定某个程序段访问，例如函数内部。需要使用local关键字进行定义，另外，函数的参数也是局部变量。如下： 12345678910#定义函数func()&#123; #使用local关键字定义局部变量 local v2=200&#125;#调用函数func#输出变量echo &quot;$v2&quot; 该执行的结果如下： 1#并没有输出任何结果，因为v2是局部变量 从以下代码来比例两种局部变量和全局变量 12345678910111213141516#定义函数func()&#123; #输出全局变量v1 echo &quot;global variable v1 is $v1&quot; #定义局部变量v1 local v1=2 #输出局部变量v1 echo &quot;local variable v1 is $v1&quot;&#125;#定义全局变量v1v1=1#调用函数func#输出全局变量v1echo &quot;global variable v1 is $v1&quot; 该执行的结果如下： 123global variable v1 is 1local variable v1 is 2global variable v1 is 1 注意Shell变量中的符号”$”表示取变量的值。只有在取值的时候才使用，定义和赋值是无需使用符号”$”，另外，实际上Shell中变量的原型为${var}，$var为简写，在某些情况下，简写会导致程序执行错误。 系统变量Shell语言的系统变量主要在对参数判断和命令返回值判断时使用，包括脚本和函数参数，已经脚本和函数的返回值。Shell语言中的系统变量并不多，但是十分有用，特别是在做一些参数检测的时候。一些常用的系统变量： 变量 说明 $n n是第一个整数，从1开始，表示参数的位置，例如$1表示第1个参数，$2表示第2个参数 $# 命令行参数的个数 $0 当前Shell脚本的名称 $? 前一个命令或者函数的返回状态码 $* 以”参数1””参数2”……的形式将所有参数通过一个字符串返回 $@ 以”参数1””参数2”……的形式返回每个参数 $$ 返回本程序的进程ID（PID） 下面是常用的系统变量的使用方法： 12345678910#输出脚本的参数个数echo &quot;the number of parameters is $#&quot;#输出上一个命令的退出状态码echo &quot;the return code of last command is $?&quot;#输出当前脚本的名称echo &quot;the script name is $0&quot;#输出所有的参数echo &quot;the parameters are $*&quot;#输出其中的几个参数echo &quot;\$1=$1;\$2=$2;\$11=$&#123;11&#125;&quot; 环境变量Shell的环境变量是所有Shell程序都可以使用的变量。Shell程序在运行时，都会接收一组变量，这组变量就是环境变量。环境变量会影响到所有脚本的执行结果。如下是一些常用的环境变量： 变量 说明 PATH 命令搜索路径，以冒号为分隔符。注意Windows下不同的是，当前目录不在系统路径里 HOME 用户主目录的路径名，是cd命令的默认参数 COLUMNS 定义了命令编辑模式下可使用命令行的长度 HISTFILE 命令历史文件 HISFILESIZE 命令历史文件中最多可包含的命令条数 IFS 定义Shell使用的分隔符 LOGNAME 当前的登录名 SHELL Shell的全路径名 TERM 终端类型 TMOUT Shell自动退出的时刻，单位为秒，若设置为0则禁止Shell自动退出 PWD 当前工作目录 可以使用set命令列出系统所有的环境变量： 1set | more 12345678910111213141516171819202122&apos;!&apos;=0&apos;#&apos;=0&apos;$&apos;=6491&apos;*&apos;=( )-=569JNRXghikls0=-zsh&apos;?&apos;=0@=( )ARGC=0Apple_PubSub_Socket_Render=/private/tmp/com.apple.launchd.A6yPyflyoi/RenderBGCDPATH=&apos;&apos;COLORFGBG=&apos;12;8&apos;COLUMNS=80CPUTYPE=x86_64CURRENT_BG=NONEEGID=20EUID=501FGFIGNORE=&apos;&apos;FPATH=/Users/wangchonglei/.oh-my-zsh/plugins/git:/Users/wangchonglei/.oh-my-zsh/functions:/Users/wangchonglei/.oh-my-zsh/completions:/usr/local/share/zsh/site-functions:/usr/share/zsh/site-functions:/usr/share/zsh/5.2/functionsFX 使用范例代码： 12345678910#输出命令搜索路径echo &quot;commands path is $PATH&quot;#输出当前的登录名echo &quot;current login name is $LOGName&quot;#输出当前用户的主目录echo &quot;current user&apos;s home is $HOME&quot;#输出当前的Shellecho &quot;current shell is $SHELL&quot;#输出当前的工作目录echo &quot;current path is $PWD&quot; 最近在学习Shell，把学习中的一些知识点记录下来，供以后自己复习使用。谢谢大家的阅读，有什么问题欢迎指出~~ 作者 @W_C__L2016 年 09月 20日]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Shell学习小结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发进阶 - 使用Carthage管理iOS第三方库]]></title>
    <url>%2F2016%2F09%2F20%2FiOS%E5%BC%80%E5%8F%91%E8%BF%9B%E9%98%B6-%E4%BD%BF%E7%94%A8Carthage%E7%AE%A1%E7%90%86iOS%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%2F</url>
    <content type="text"><![CDATA[最近在研究Swift，一不小心发现一个好的的管理iOS第三方库Carthage，就跟第一次使用CocoaPods时一样兴奋不已，在研究了大半天后终于能用了，使用起来还是很方便的，比起CocoaPods有不足也有优点，两个配合起来用也是很爽的^ - ^ 初识Carthage最近在用Swift3.0做项目，想导入一些支持Swift3.0的第三方库来使用，就想到Alamofire，看README时发现了一个新的名词Carthage，What？，这是个什么东西，居然也可以用它来管理第三方库，之前都没见到过，赶紧百度了一下补充了下知识： Carthage：迦太基（地中海地区古城），好吧这是百度百科的解释，至于为什么用这个单词，我也不太清楚，可能比较屌吧，看下图你就知道它是用来干什么的了： Carthage的目标是用最简单的方式来管理Cocoa第三方框架 是的，你没看错，它可以用来管理第三方库Alamofire，然后查了一下，还有很多第三方库都可以用它来管理，跟CocoaPods一样可以用来管理第三方库，看了一下它的崛起时间大概是iOS8之后Swift出来的时候，与现在流行的 CocoaPods 不同，它是一个去中心化的解决方案。CocoaPods的方法更易于使用，但Carthage更灵活并且是非侵入性的。 大家都知道Swift是支持动态库的，所以Carthage应势而生，它没有总项目的列表，这能够减少维护工作并且避免任何中心化带来的问题）。不过，这样也有一些缺点，就是想修改第三方库源码的话很费劲，还需要重新编译打包。 安装和使用Carthage首先到github上Download或者Clone Git 或者使用HomeBrew（没有安装的可以自行百度去装一个）安装~ 12brew update #先更新brew install carthage #安装Carthage 当你安装好Carthage后，在终端执行来判断是否安装成功： 1carthage version 即可看到当前的Carthage版本, 当我写这篇文章的时候，Carthage的版本为0.18（还是很年轻的嘛） 。 现在，你已经安装好了Carthage，接下来就是在你的项目中使用carthage了： 1vim Cartfile #创建一个叫Cartfile的文件 输入你想要编译成Framework的Swift第三方库，比如说SnapKit和Alamofire，如下所示： 12github &quot;Alamofire/Alamofire&quot; ~&gt; 4.0 #支持Swift3.0github &quot;SnapKit/SnapKit&quot; ~&gt; 3.0 #支持Swift3.0 github代表源，而后面的就是用户名和版本库的名字，而”~&gt;” 后面是版本号哈！ 保存退出，执行： 1carthage update --platform iOS #因为是打包iOS的所以后面加iOS，有的库支持mac、watch的话会打几个包 之后会发现在跟目录下多出了Carthage文件夹和Cartfile.resolved文件。进入Carthage/Checkouts下可以看到刚刚得到的Alamofire和SnapKit，如下图所示： 现在打开你的项目，点击project，选择target, 再选择上方的General，将需要的framework文件拖到 Linked frameworks and Binaries内： 然后这是很重要的一步，点击Build Phrase tab选项，添加相应的run script： 12/usr/local/bin/carthage copy-frameworks$(SRCROOT)/Carthage/Build/iOS/你的framework 然后就可以去项目里面import你得第三方库了~~可以愉快的使用了，不过有一点要吐槽一下`build的速度真是有点慢- . - CocoaPods的优势与劣势优势 使用方便，除编写 Podfile 以外其他几乎都是自动完成； 软件包数量多，主流支持； 支持 iOS 8 Framework，当然也支持旧的静态编译； 开发者使用比较简单，但是如果创建兼容 CocoaPods 的库，就会相对繁琐一些（尽管有了命令行）~ 劣势 每次clean后都得重新编译，编译比较耗时，Archive也会变慢； 每次更新环境都需要连接到中心仓库，比较耗时~ Carthage的优势与劣势优势 build一次后就能在项目里面使用，增加编译速度； 可以与CocoaPods无缝集成； 它是去中心化的，没有中心服务器，这意味着每次配置和更新环境，只会去更新具体的库，而不会有一个向中心服务器获取最新库的索引这么个过程，如此一来，又省了很多时间； 不会影响你的项目配置的，相对CocoaPods而言更加独立，Carthage 使用的是一种非侵入性的哲学； 劣势 库依然不如 CocoaPods 丰富：尽管很多库不需要声明并改造就直接可以被 Carthage 用，但依然有大量 CocoaPods 能用的库不支持，我相信时间能解决这个问题； 只支持 Framework，所以是 iOS 8 Only 了，随着时间推移，这个也不会是问题； 无法在 Xcode 里定位到源码：如果你在写代码过程中，想跳转到一个第三方库去看具体的实现，这是无法办到的，Carthage 的配置只能让你看到一个库的头文件~ 总结我觉得不管怎样，好不好用，做为iOS程序员我们都应该去尝试的了解一下它，通过它去学到更多的东西，至于什么第三方库用CocoaPods，什么去用Carthage，我觉得一些比较稳定大的库可以用Carthage，而一些变动比较大，自己还有可能去修改的库我们肯定首选CocoaPods。最后希望大家看到这篇博客能学到东西，大家有问题可以提出来，谢谢大家的阅读~~ 参考链接http://www.jianshu.com/p/5ccde5f22a17 https://imtx.me/archives/1939.html 作者 @W_C__L2016 年 09月 20日]]></content>
      <categories>
        <category>iOS开发进阶</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS基于XMPP实现即时通讯之一、环境的搭建]]></title>
    <url>%2F2016%2F09%2F16%2FiOS%E5%9F%BA%E4%BA%8EXMPP%E5%AE%9E%E7%8E%B0%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%E4%B9%8B%E4%B8%80%E3%80%81%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[使用XMPP已经有一段时间了，但是一直都没深入研究过，只是使用SDK做一些简单的操作，看了许多大神的博客，自己总结一下，准备写一系列关于XMPP的使用博客，以便于自己更加深入学习~ IM协议及服务器选型http://liudanking.me/arch/xmpp%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%89%E5%9E%8B/协议选型：XMPP已经成为标准的IM协议。XMPP官网：http://XMPP.org/服务器型：使用广泛的是ejabberd，jabberd 2.x， Openfire，Tigase。从编程语言角度来看主要是JAVA和Erlang。JAVA语言的优势是类库完备，容易招人。Erlang的优势是hot code swap，live console， 高并发。而且ejabberd是对XMPP协议支持最好、实现最为全面的server。因此企业在不考虑独立开发服务器的情况下，初期选型基本建议采用ejabberd。 本文我们主要实践iOS端流程，不考虑太多服务器实现，因为Openfire易安装，插件功能丰富，我们使用Openfire MAC上搭建MySQL因为服务器需要数据库支撑，所以我们在搭建Openfire前要先搭建数据库。 下载MySQL安装包我们先去MySQL官网去下载MySQL的安装包，如下图所示： 安装MySQL下载完后，开始安装MySQL如下图： 注意事项：因为安装完MySQL后它会自动给你生成一个密码，所以你要保存好这个密码，后面修改密码的时候会用到，如下图所示： 配置MySQL启动MySQL首先在设置里面找到MySQL的启动按钮，启动MySQL服务，如下图： 定义MySQL别名然后需要将MySQL的指令重新定义一下，因为MySQL的指令集在/usr/local/mysql/bin/mysql路径下，需要执行一下命令行： 1234# 定义mysql别名alias mysql=/usr/local/mysql/bin/mysql# mysqladminalias mysqladmin=/usr/local/mysql/bin/mysqladmin 修改MySQL账户密码之前安装完成后系统给我们了一个默认的密码，因为那个密码很繁琐不容易记住，所以我们需要重新设置一个密码，我们先输入如下指令设置新密码，”newpassword”为你要设置的新密码： 12mysqladmin -u root -p password &quot;newpassword&quot;#然后 Enter password: 【输入原来的密码】 如下图所示表示密码修改成功： 完成后以后root账户需要密码就用你新设置的密码就行了~ 连接数据库，创建Openfire数据库1234# 连接数据库mysql -u root -p# 创建Openfire数据库create database openfire; 完全卸载MySQL在系统内存不够时有时候我们会需要删除掉MySQL，一下就是删除MySQL的方法： 从 Yosemite 系统开始，/etc/hostconfig 这个文件已经移除，所以 Yosemite 后的系统可以忽略下面的命令 sudo nano /etc/hostconfig 然后以下是终端执行代码： 123456789sudo rm -rf /usr/local/mysql sudo rm -rf /usr/local/mysql* sudo rm -rf /Library/StartupItems/MySQLCOM sudo rm -rf /Library/PreferencePanes/My* sudo nano /etc/hostconfig (复制前面部分回车，然后删掉这一行: MYSQLCOM=-YES-，control+O回车保存，control+X退出编辑界面) sudo rm -rf ~/Library/PreferencePanes/My* sudo rm -rf /Library/Receipts/mysql* sudo rm -rf /Library/Receipts/MySQL* sudo rm -rf /var/db/receipts/com.mysql.* MAC上搭建Openfire下载并安装openfire去openfire官网上去下载相应的包： 双击进行傻瓜式的安装就好了，安装完毕后会在系统偏好设置里面找到openfire的启动器 点击Openfire会进入启动页面 点击Open Admin Console进入浏览器设置页面，语言选择简体中文 接着设置服务器的名字 链接数据库 注意里面的用户名和密码是你数据库的用户名和密码，用户名一般是root，密码是你之前重新设置的密码~~~ 然后一直继续就OK了，最后需要我们登录到openfire 密码就是之前设置的密码 openfire启动失败解决办法 当你发现你的电脑上的openfire无论你是重新安装还是重启都无法启动的情况下你可以按照我下面写的那些终端指令来启动你的openfire不用再去重新做你的系统了. 一般你发现你的openfire打开出现这样的窗口后你就可以想到你的openfire出问题了,极个别的时候你可以通过重新安装来解决. 如果大家的问题重新安装后没有解决那就试下我下面的方法. 先打开自己电脑上的终端然后输入以下指令: 1234567891011// 获取权限sudo chmod -R 777 /usr/local/openfire/bincd /usr/local/openfire/binexport JAVA_HOME=`/usr/libexec/java_home` # 记住这里不是单引号而是英文下数字1左边的按键.echo $JAVA_HOME# 终端上打印的内容 /Library/Java/JavaVirtualMachines/jdk1.8.0_25.jdk/Contents/Homecd /usr/local/openfire/bin./openfire.sh# 终端上打印的内容# Openfire 4.0.3 [Sep 16, 2016 4:19:21 PM]# Admin console listening at http://wangchongleidemacbook-air.local:9090 一般你输入完成这些指令后你再打开你的openfire就会发现这样的情况. 安装openfire后admin无法登录管理控制平台 解决方案如下： 使用Mysql查看工具进入数据库，进入表“ofuser”，将该表清空，然后执行SQL 语句 1INSERT INTO ofUser (username, plainPassword, name, email, creationDate, modificationDate) VALUES (&apos;admin&apos;, &apos;admin&apos;, &apos;Administrator&apos;, &apos;admin@example.com&apos;, &apos;0&apos;, &apos;0&apos;); 关闭openfire服务，就是从其控制台stop然后再start，再用用户名：admin,密码：admin登录即可. 彻底删除openfire服务器的首先,确保你已经关掉了openfire打开终端 (在应用程序–&gt;实用工具–&gt;)输入以下命令 123sudo rm -rf /Library/PreferencePanes/Openfire.prefPanesudo rm -rf /usr/local/openfiresudo rm -rf /Library/LaunchDaemons/org.jivesoftware.openfire.plist 第一条会让你输入管理员密码,尽管你输入的时候,终端不会显示,不必担心,正确输入后按回车,它就执行了。三条命令以后，openfire就彻底消失了.但是需要重启一下系统偏设置。 总结配置过程还是比较繁琐的，一共需要好几个步骤，需要装的有MySQL、JAVA环境和openfire，里面有一步没做好都没法使用，自己完整配置下来也花了很长时间，大家如果有什么问题可以留言问我，谢谢大家的阅读~~ 参考文档：http://www.cnblogs.com/xiaodao/archive/2013/04/04/2999426.html http://www.cnblogs.com/xiaodao/archive/2013/04/05/3000554.html http://www.jianshu.com/p/5d88fe201c71 作者 @W_C__L2016 年 09月 16日]]></content>
      <categories>
        <category>XMPP学习</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS动画进阶 - 手摸手教你写 Slack 的 Loading 动画]]></title>
    <url>%2F2016%2F09%2F08%2FiOS%E5%BC%80%E5%8F%91%E8%BF%9B%E9%98%B6-%E6%89%8B%E6%91%B8%E6%89%8B%E6%95%99%E4%BD%A0%E5%86%99-Slack-%E7%9A%84-Loading-%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[前几天看了一篇关于动画的博客叫手摸手教你写 Slack 的 Loading 动画，看着挺炫，但是是安卓版的，寻思的着仿造着写一篇iOS版的，下面是我写这个动画的分解~ 老规矩先上图和demo地址： 刚看到这个动画的时候，脑海里出现了两个方案，一种是通过drawRect画出来，然后配合CADisplayLink不停的绘制线的样式；第二种是通过CAShapeLayer配合CAAnimation来实现动画效果。再三考虑觉得使用后者，因为前者需要计算很多，比较复杂，而且经过测试前者相比于后者消耗更多的CPU，下面将我的思路写下来： 相关配置和初始化方法在写这个动画之前，我们把先需要的属性写好，比如线条的粗细，动画的时间等等，下面是相关的配置和初识化方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//线的宽度var lineWidth:CGFloat = 0//线的长度var lineLength:CGFloat = 0//边距var margin:CGFloat = 0//动画时间var duration:Double = 2//动画的间隔时间var interval:Double = 1//四条线的颜色var colors:[UIColor] = [UIColor.init(rgba: "#9DD4E9") , UIColor.init(rgba: "#F5BD58"), UIColor.init(rgba: "#FF317E") , UIColor.init(rgba: "#6FC9B5")]//动画的状态private(set) var status:AnimationStatus = .Normal//四条线private var lines:[CAShapeLayer] = []enum AnimationStatus &#123; //普通状态 case Normal //动画中 case Animating //暂停 case pause&#125; //MARK: Initial Methodsconvenience init(fram: CGRect , colors: [UIColor]) &#123; self.init() self.frame = frame self.colors = colors config()&#125;override init(frame: CGRect) &#123; super.init(frame: frame) config()&#125;required init?(coder aDecoder: NSCoder) &#123; super.init(coder: aDecoder) config()&#125;private func config() &#123; lineLength = max(frame.width, frame.height) lineWidth = lineLength/6.0 margin = lineLength/4.5 + lineWidth/2 drawLineShapeLayer() transform = CGAffineTransformRotate(CGAffineTransformIdentity, angle(-30))&#125; 通过CAShapeLayer绘制线条看到这个线条我就想到了用CAShapeLayer来处理，因为CAShapeLayer完全可以实现这种效果，而且它的strokeEnd的属性可以用来实现线条的长度变化的动画，下面上绘制四根线条的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//MARK: 绘制线 /** 绘制四条线 */ private func drawLineShapeLayer() &#123; //开始点 let startPoint = [point(lineWidth/2, y: margin), point(lineLength - margin, y: lineWidth/2), point(lineLength - lineWidth/2, y: lineLength - margin), point(margin, y: lineLength - lineWidth/2)] //结束点 let endPoint = [point(lineLength - lineWidth/2, y: margin) , point(lineLength - margin, y: lineLength - lineWidth/2) , point(lineWidth/2, y: lineLength - margin) , point(margin, y: lineWidth/2)] for i in 0...3 &#123; let line:CAShapeLayer = CAShapeLayer() line.lineWidth = lineWidth line.lineCap = kCALineCapRound line.opacity = 0.8 line.strokeColor = colors[i].CGColor line.path = getLinePath(startPoint[i], endPoint: endPoint[i]).CGPath layer.addSublayer(line) lines.append(line) &#125; &#125; /** 获取线的路径 - parameter startPoint: 开始点 - parameter endPoint: 结束点 - returns: 线的路径 */ private func getLinePath(startPoint: CGPoint, endPoint: CGPoint) -&gt; UIBezierPath &#123; let path = UIBezierPath() path.moveToPoint(startPoint) path.addLineToPoint(endPoint) return path &#125; private func point(x:CGFloat , y:CGFloat) -&gt; CGPoint &#123; return CGPointMake(x, y) &#125; private func angle(angle: Double) -&gt; CGFloat &#123; return CGFloat(angle * (M_PI/180)) &#125; 执行完后就跟上图一样的效果了~~~ 动画分解经过分析，可以将动画分为四个步骤： 画布的旋转动画，旋转两圈 线条由长变短的动画，更画布选择的动画一起执行，旋转一圈的时候结束 线条的位移动画，线条逐渐向中间靠拢，再画笔旋转完一圈的时候执行，两圈的时候结束 线条由短变长的动画，画布旋转完两圈的时候执行 第一步画布旋转动画这里我们使用CABasicAnimation基础动画，keyPath作用于画布的transform.rotation.z，以z轴为目标进行旋转，下面是效果图和代码： 1234567891011121314//MARK: 动画步骤 /** 旋转的动画，旋转两圈 */ private func angleAnimation() &#123; let angleAnimation = CABasicAnimation.init(keyPath: "transform.rotation.z") angleAnimation.fromValue = angle(-30) angleAnimation.toValue = angle(690) angleAnimation.fillMode = kCAFillModeForwards angleAnimation.removedOnCompletion = false angleAnimation.duration = duration angleAnimation.delegate = self layer.addAnimation(angleAnimation, forKey: "angleAnimation") &#125; 第二步线条由长变短的动画这里我们还是使用CABasicAnimation基础动画，keyPath作用于线条的strokeEnd属性，让strokeEnd从1到0来实现线条长短的动画，下面是效果图和代码： 123456789101112131415/** 线的第一步动画，线长从长变短 */ private func lineAnimationOne() &#123; let lineAnimationOne = CABasicAnimation.init(keyPath: "strokeEnd") lineAnimationOne.duration = duration/2 lineAnimationOne.fillMode = kCAFillModeForwards lineAnimationOne.removedOnCompletion = false lineAnimationOne.fromValue = 1 lineAnimationOne.toValue = 0 for i in 0...3 &#123; let lineLayer = lines[i] lineLayer.addAnimation(lineAnimationOne, forKey: "lineAnimationOne") &#125; &#125; 第三步线条的位移动画这里我们也是使用CABasicAnimation基础动画，keyPath作用于线条的transform.translation.x和transform.translation.y属性，来实现向中间聚拢的效果，下面是效果图和代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** 线的第二步动画，线向中间平移 */ private func lineAnimationTwo() &#123; for i in 0...3 &#123; var keypath = "transform.translation.x" if i%2 == 1 &#123; keypath = "transform.translation.y" &#125; let lineAnimationTwo = CABasicAnimation.init(keyPath: keypath) lineAnimationTwo.beginTime = CACurrentMediaTime() + duration/2 lineAnimationTwo.duration = duration/4 lineAnimationTwo.fillMode = kCAFillModeForwards lineAnimationTwo.removedOnCompletion = false lineAnimationTwo.autoreverses = true lineAnimationTwo.fromValue = 0 if i &lt; 2 &#123; lineAnimationTwo.toValue = lineLength/4 &#125;else &#123; lineAnimationTwo.toValue = -lineLength/4 &#125; let lineLayer = lines[i] lineLayer.addAnimation(lineAnimationTwo, forKey: "lineAnimationTwo") &#125; //三角形两边的比例 let scale = (lineLength - 2*margin)/(lineLength - lineWidth) for i in 0...3 &#123; var keypath = "transform.translation.y" if i%2 == 1 &#123; keypath = "transform.translation.x" &#125; let lineAnimationTwo = CABasicAnimation.init(keyPath: keypath) lineAnimationTwo.beginTime = CACurrentMediaTime() + duration/2 lineAnimationTwo.duration = duration/4 lineAnimationTwo.fillMode = kCAFillModeForwards lineAnimationTwo.removedOnCompletion = false lineAnimationTwo.autoreverses = true lineAnimationTwo.fromValue = 0 if i == 0 || i == 3 &#123; lineAnimationTwo.toValue = lineLength/4 * scale &#125;else &#123; lineAnimationTwo.toValue = -lineLength/4 * scale &#125; let lineLayer = lines[i] lineLayer.addAnimation(lineAnimationTwo, forKey: "lineAnimationThree") &#125; &#125; 第四步线条恢复的原来长度的动画这里我们还是使用CABasicAnimation基础动画，keyPath作用于线条的strokeEnd属性，让strokeEnd从0到1来实现线条长短的动画，下面是效果图和代码： 1234567891011121314151617181920/** 线的第三步动画，线由短变长 */ private func lineAnimationThree() &#123; //线移动的动画 let lineAnimationFour = CABasicAnimation.init(keyPath: "strokeEnd") lineAnimationFour.beginTime = CACurrentMediaTime() + duration lineAnimationFour.duration = duration/4 lineAnimationFour.fillMode = kCAFillModeForwards lineAnimationFour.removedOnCompletion = false lineAnimationFour.fromValue = 0 lineAnimationFour.toValue = 1 for i in 0...3 &#123; if i == 3 &#123; lineAnimationFour.delegate = self &#125; let lineLayer = lines[i] lineLayer.addAnimation(lineAnimationFour, forKey: "lineAnimationFour") &#125; &#125; 最后一步需要将动画组合起来关于动画组合我没用到CAAnimationGroup，因为这些动画并不是加到同一个layer上，再加上动画类型有点多加起来也比较麻烦，我就通过动画的beginTime属性来控制动画的执行顺序，还加了动画暂停喝继续的功能，效果和代码见下图： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//MARK: Public Methods /** 开始动画 */ func startAnimation() &#123; angleAnimation() lineAnimationOne() lineAnimationTwo() lineAnimationThree() &#125; /** 暂停动画 */ func pauseAnimation() &#123; layer.pauseAnimation() for lineLayer in lines &#123; lineLayer.pauseAnimation() &#125; status = .pause &#125; /** 继续动画 */ func resumeAnimation() &#123; layer.resumeAnimation() for lineLayer in lines &#123; lineLayer.resumeAnimation() &#125; status = .Animating &#125; extension CALayer &#123; //暂停动画 func pauseAnimation() &#123; // 将当前时间CACurrentMediaTime转换为layer上的时间, 即将parent time转换为localtime let pauseTime = convertTime(CACurrentMediaTime(), fromLayer: nil) // 设置layer的timeOffset, 在继续操作也会使用到 timeOffset = pauseTime // localtime与parenttime的比例为0, 意味着localtime暂停了 speed = 0; &#125; //继续动画 func resumeAnimation() &#123; let pausedTime = timeOffset speed = 1 timeOffset = 0; beginTime = 0 // 计算暂停时间 let sincePause = convertTime(CACurrentMediaTime(), fromLayer: nil) - pausedTime // local time相对于parent time时间的beginTime beginTime = sincePause &#125;&#125;//MARK: Animation Delegate override func animationDidStart(anim: CAAnimation) &#123; if let animation = anim as? CABasicAnimation &#123; if animation.keyPath == "transform.rotation.z" &#123; status = .Animating &#125; &#125; &#125; override func animationDidStop(anim: CAAnimation, finished flag: Bool) &#123; if let animation = anim as? CABasicAnimation &#123; if animation.keyPath == "strokeEnd" &#123; if flag &#123; status = .Normal dispatch_after(dispatch_time(DISPATCH_TIME_NOW, Int64(interval) * Int64(NSEC_PER_SEC)), dispatch_get_main_queue(), &#123; if self.status != .Animating &#123; self.startAnimation() &#125; &#125;) &#125; &#125; &#125; &#125; //MARK: Override override func touchesEnded(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent?) &#123; switch status &#123; case .Animating: pauseAnimation() case .pause: resumeAnimation() case .Normal: startAnimation() &#125; &#125; 总结动画看起来挺复杂，但是细细划分出来也就那么回事，在写动画之前要先想好动画的步骤，这个很关键，希望大家通过这篇博客可以学到东西，有什么好的建议可以随时提出来，谢谢大家阅读~~demo地址 作者 @W_C__L2016 年 09月 08日]]></content>
      <categories>
        <category>iOS动画进阶</category>
      </categories>
      <tags>
        <tag>iOS动画进阶进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发进阶 - 使用shell脚本自动打包上传到fir上]]></title>
    <url>%2F2016%2F08%2F24%2FiOS%E5%BC%80%E5%8F%91%E8%BF%9B%E9%98%B6-%E4%BD%BF%E7%94%A8shell%E8%84%9A%E6%9C%AC%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85%E4%B8%8A%E4%BC%A0%E5%88%B0fir%E4%B8%8A%2F</url>
    <content type="text"><![CDATA[用fir.im测试已经好长时间了，感觉每次打包上传都很麻烦，想着是不是可以用脚本自动打包，在网上搜了一下确实有，下面总结一下如何使用脚本自动打包上传到fir.im，以及打包过程中遇到的问题和解决办法 相关资料和下载首先是打包脚本的下载地址，这个是我找到的比较全的一个，里面有很多不同功能的shell脚本，亲测好用，传送门 还有关于fir指令的一些介绍可以去这里查看，传送门 第一步安装fir-cilfir-cli 使用 Ruby 构建, 无需编译, 只要安装相应 gem 即可. 12$ ruby -v # &gt; 1.9.3$ gem install fir-cli 常见的安装问题 使用系统自带的 Ruby 安装, 需确保 ruby-dev 已被正确的安装: 12$ xcode-select --install # OS X 系统$ sudo apt-get install ruby-dev # Linux 系统 出现 Permission denied 相关错误: 在命令前加上 sudo 出现 Gem::RemoteFetcher::FetchError 相关错误: 更换 Ruby 的淘宝源(由于国内网络原因, 你懂的), 并升级下系统自带的 gem 12345678910$ gem sources --remove https://rubygems.org/$ gem sources -a https://ruby.taobao.org/$ gem sources -l*** CURRENT SOURCES ***https://ruby.taobao.org# 请确保只有 ruby.taobao.org, 如果有其他的源, 请 remove 掉gem update --systemgem install fir-cli Mac OS X 10.11 以后的版本, 由于10.11引入了 rootless, 无法直接安装 fir-cli, 有以下三种解决办法: 1. 使用 Homebrew 及 RVM 安装 Ruby, 再安装 fir-cli(推荐) 1234567# Install Homebrew:$ ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"# Install RVM:$ \curl -sSL https://get.rvm.io | bash -s stable --ruby$ gem install fir-cli 2. 指定 fir-cli 中 bin 文件的 PATH 1$ export PATH=/usr/local/bin:$PATH;gem install -n /usr/local/bin fir-cli 3. 重写 Ruby Gem 的 bindir 12$ echo 'gem: --bindir /usr/local/bin' &gt;&gt; ~/.gemrc$ gem install fir-cli 第二步登录fir.im登录指令非常简单，只需要fir login API Token，这里面的API Token就是你fir帐号下的API Token，然后通过fir me查看你是否登录成功. 首先获取API Token 在终端里登录你的fir12fir login API Tokenfir me 如果出现一下类似的情况说明登录成功了. 获取需要上传应用的appID 第三步使用下载下来的shell脚本进行打包上传先看一下脚本代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#! bin/bash#Author:Bruce http://www.heyuan110.com#Update Date:2015.06.23#Use:命令行进入目录直接执行sh Build+DeployToFir.sh即可完成打包发布到fir.imexport LC_ALL=zh_CN.GB2312;export LANG=zh_CN.GB2312###############设置需编译的项目配置名称buildConfig="Release" #编译的方式,有Release,Debug，自定义的AdHoc等########################################################################################################################以下部分为自动生产部分，不需要手动修改######################################################################################################################projectName=`find . -name *.xcodeproj | awk -F "[/.]" '&#123;print $(NF-1)&#125;'` #项目名称projectDir=`pwd` #项目所在目录的绝对路径wwwIPADir=~/Desktop/$projectName-IPA #ipa，icon最后所在的目录绝对路径isWorkSpace=true #判断是用的workspace还是直接project，workspace设置为true，否则设置为falseecho "~~~~~~~~~~~~~~~~~~~开始编译~~~~~~~~~~~~~~~~~~~"if [ -d "$wwwIPADir" ]; then echo $wwwIPADir echo "文件目录存在" else echo "文件目录不存在" mkdir -pv $wwwIPADir echo "创建$&#123;wwwIPADir&#125;目录成功"fi###############进入项目目录cd $projectDirrm -rf ./buildbuildAppToDir=$projectDir/build #编译打包完成后.app文件存放的目录###############获取版本号,bundleIDinfoPlist="$projectName/Info.plist"bundleVersion=`/usr/libexec/PlistBuddy -c "Print CFBundleShortVersionString" $infoPlist`bundleIdentifier=`/usr/libexec/PlistBuddy -c "Print CFBundleIdentifier" $infoPlist`bundleBuildVersion=`/usr/libexec/PlistBuddy -c "Print CFBundleVersion" $infoPlist`###############开始编译appif $isWorkSpace ; then #判断编译方式 echo "开始编译workspace...." xcodebuild -workspace $projectName.xcworkspace -scheme $projectName -configuration $buildConfig clean build SYMROOT=$buildAppToDirelse echo "开始编译target...." xcodebuild -target $projectName -configuration $buildConfig clean build SYMROOT=$buildAppToDirfi#判断编译结果if test $? -eq 0thenecho "~~~~~~~~~~~~~~~~~~~编译成功~~~~~~~~~~~~~~~~~~~"elseecho "~~~~~~~~~~~~~~~~~~~编译失败~~~~~~~~~~~~~~~~~~~"exit 1fi###############开始打包成.ipaipaName=`echo $projectName | tr "[:upper:]" "[:lower:]"` #将项目名转小写findFolderName=`find . -name "$buildConfig-*" -type d |xargs basename` #查找目录appDir=$buildAppToDir/$findFolderName/ #app所在路径echo "开始打包$projectName.app成$projectName.ipa....."xcrun -sdk iphoneos PackageApplication -v $appDir/$projectName.app -o $appDir/$ipaName.ipa #将app打包成ipa###############开始拷贝到目标下载目录#检查文件是否存在if [ -f "$appDir/$ipaName.ipa" ]thenecho "打包$ipaName.ipa成功."elseecho "打包$ipaName.ipa失败."exit 1fipath=$wwwIPADir/$projectName$(date +%Y%m%d%H%M%S).ipacp -f -p $appDir/$ipaName.ipa $path #拷贝ipa文件echo "复制$ipaName.ipa到$&#123;wwwIPADir&#125;成功"echo "~~~~~~~~~~~~~~~~~~~结束编译，处理成功~~~~~~~~~~~~~~~~~~~"#open $wwwIPADir#####开始上传，如果只需要打ipa包出来不需要上传，可以删除下面的代码export LANG=en_USexport LC_ALL=en_US;echo "正在上传到fir.im...."#####http://fir.im/api/v2/app/appID?token=APIToken，里面的appID是你要上传应用的appID，APIToken是你fir上的APITokenfir p $pathchangelog=`cat $projectDir/README`curl -X PUT --data "changelog=$changelog" http://fir.im/api/v2/app/appID?token=APITokenecho "\n打包上传更新成功！"rm -rf $buildAppToDirrm -rf $projectDir/tmp 上面对关键代码都做了详细解释，下面只需要执行shell脚本就能打包上传了。 执行shell脚本，打包上传 首先把这个脚本文件放到你的项目工程目录下 然后打开终端，cd到脚本文件在的目录下，执行命名sh build_deployto_fir.sh 然后看到一下类似的画面说明上传成功： 执行脚本过程中遇到的问题和解决方案fir: command not found这个是因为没有安装fir-cil，导致找不到相应的命令行，只需要安装一下就行了，详情见上文写的如何安装fir-cil。 README: No such file or directory那是因为你的脚本目录下没有README的文件，只需要建一个README的文件就行了，打开终端，cd到当前位置，然后执行下面的命令：1touch README ERROR – : Token can not be blank这个原因是因为你没有登录fir导致的，你执行这个脚本之前应该先登录一下fir，详情请看上文写的登录fir.im。 以上就是我对于打包上传到fir上的脚本使用的总结，如果大家有问题可以随时问我，谢谢大家的阅读。 作者 @W_C__L2016 年 08月 24日]]></content>
      <categories>
        <category>iOS开发进阶</category>
      </categories>
      <tags>
        <tag>iOS开发进阶 shell脚本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发进阶 - 实现类似美颜相机的相机启动动画]]></title>
    <url>%2F2016%2F08%2F16%2FiOS%E5%BC%80%E5%8F%91%E8%BF%9B%E9%98%B6-%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%BC%BC%E7%BE%8E%E9%A2%9C%E7%9B%B8%E6%9C%BA%E7%9A%84%E7%9B%B8%E6%9C%BA%E5%90%AF%E5%8A%A8%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[最近在写一个相册的demo，偶尔看到了美拍的相机过载动画觉得很有意思，就想在我的相册demo中加入一个这种特效，下面把我的想法和实现过程给大家分享一下 先上效果图：（demo地址） 步骤分析这个动效看起来很有特色但是实现起来是非常简单的，只需要用到CALayer和CAShapeLayer做为展示层，然后通过CABasicAnimation实现动画就行了~ 用两个CALayer来呈现启动的image 通过UIBezierPath和CAShapeLayer来画出具有曲线的CAShapeLayer 然后将曲线的CAShapeLayer做为CALayer的mask 最后通过CABasicAnimation做一个简单的位移动画 先绘制上半部分的layer12345678910111213141516171819202122/** 绘制上半部分的layer */ private func configTopShapeLayer() &#123; //绘制贝斯尔曲线 let topBezier:UIBezierPath = UIBezierPath() topBezier.moveToPoint(CGPointMake(-1, -1)) topBezier.addLineToPoint(CGPointMake(bounds.width+1, -1)) topBezier.addCurveToPoint(CGPointMake(bounds.width/2.0+1, bounds.height/2.0+1), controlPoint1: CGPointMake(bounds.width+1, 0+1), controlPoint2: CGPointMake(343.5+1, 242.5+1)) topBezier.addCurveToPoint(CGPointMake(-1, bounds.height+2), controlPoint1: CGPointMake(31.5+2, 424.5+2), controlPoint2: CGPointMake(0+2, bounds.height+2)) topBezier.addLineToPoint(CGPointMake(-1, -1)) topBezier.closePath() //创建一个CAShapeLayer，将绘制的贝斯尔曲线的path给CAShapeLayer let topShape = CAShapeLayer() topShape.path = topBezier.CGPath //给topLayer设置contents为启动图 topLayer.contents = launchImage?.CGImage topLayer.frame = bounds layer.addSublayer(topLayer) //将绘制后的CAShapeLayer做为topLayer的mask topLayer.mask = topShape &#125; 绘制后的结果是这样的： 然后以同样的原理绘制下半部分的layer12345678910111213141516171819202122/** 绘制下半部分的layer */ private func configBottomShapeLayer() &#123; //绘制贝斯尔曲线 let bottomBezier:UIBezierPath = UIBezierPath() bottomBezier.moveToPoint(CGPointMake(bounds.width, 0)) bottomBezier.addCurveToPoint(CGPointMake(bounds.width/2.0, bounds.height/2.0), controlPoint1: CGPointMake(bounds.width, 0), controlPoint2: CGPointMake(343.5, 242.5)) bottomBezier.addCurveToPoint(CGPointMake(0, bounds.height), controlPoint1: CGPointMake(31.5, 424.5), controlPoint2: CGPointMake(0, bounds.height)) bottomBezier.addLineToPoint(CGPointMake(bounds.width, bounds.height)) bottomBezier.addLineToPoint(CGPointMake(bounds.width, 0)) bottomBezier.closePath() //创建一个CAShapeLayer，将绘制的贝斯尔曲线的path给CAShapeLayer let bottomShape = CAShapeLayer() bottomShape.path = bottomBezier.CGPath //给bottomLayer设置contents为启动图 bottomLayer.contents = launchImage?.CGImage bottomLayer.frame = bounds layer.addSublayer(bottomLayer) //将绘制后的CAShapeLayer做为bottomLayer的mask bottomLayer.mask = bottomShape &#125; 这里注意的是画的贝斯尔曲线上半部分的要整体向下平移1到2个像素，为了防止贝斯尔曲线画曲线导致的锯齿效果，下面是下半部分完成后的效果图： 最后给两个layer一个位移动画123456789101112131415161718192021222324252627282930313233343536373839404142/** 展开的动画 */ func starAnimation() &#123; //创建一个CABasicAnimation作用于CALayer的anchorPoint let topAnimation = CABasicAnimation.init(keyPath: "anchorPoint") //设置移动路径 topAnimation.toValue = NSValue.init(CGPoint: CGPointMake(1, 1)) //动画时间 topAnimation.duration = 0.6 //设置代理，方便完成动画后移除当前view topAnimation.delegate = self //设置动画速度为匀速 topAnimation.timingFunction = CAMediaTimingFunction.init(name: kCAMediaTimingFunctionLinear) //设置动画结束后不移除点，保持移动后的位置 topAnimation.removedOnCompletion = false topAnimation.fillMode = kCAFillModeForwards topLayer.addAnimation(topAnimation, forKey: "topAnimation") //创建一个CABasicAnimation作用于CALayer的anchorPoint let bottomAnimation = CABasicAnimation.init(keyPath: "anchorPoint") //设置移动路径 bottomAnimation.toValue = NSValue.init(CGPoint: CGPointMake(0, 0)) //动画时间 bottomAnimation.duration = 0.6 //设置动画速度为匀速 bottomAnimation.timingFunction = CAMediaTimingFunction.init(name: kCAMediaTimingFunctionLinear) //设置动画结束后不移除点，保持移动后的位置 bottomAnimation.removedOnCompletion = false bottomAnimation.fillMode = kCAFillModeForwards bottomLayer.addAnimation(bottomAnimation, forKey: "topAnimation") &#125; /** 动画完成后移除当前view */ internal override func animationDidStop(anim: CAAnimation, finished flag: Bool) &#123; if flag &#123; removeFromSuperview() &#125; &#125; 这里为了方便观察，我将动画时间变长了，下面是完成后的效果图： 到这里这个动效就完成的差不多了，希望大家能学到东西，如果大家有更好的实现办法也可以给我提意见，我学习学习，谢谢大家观看，另外附加demo地址，喜欢的可以关注一下 作者 @W_C__L2016 年 08月 16日]]></content>
      <categories>
        <category>iOS开发进阶</category>
      </categories>
      <tags>
        <tag>iOS动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发进阶 - 隐藏UINavigationBar的小技巧]]></title>
    <url>%2F2016%2F07%2F28%2FiOS%E5%BC%80%E5%8F%91%E8%BF%9B%E9%98%B6-%E9%9A%90%E8%97%8FUINavigationBar%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[在开发过程中，为让屏幕显示更多的内容，有时候设计师会让我们隐藏UINavigationBar，通过浏览大神们写的文章和工作上用到的，总结了一下隐藏UINavigationBar的三种效果，用swift写了一份，供学习使用~~~ demo地址 第一种让UINavigationBar透明渐变消失 思路是写一个扩展，先给UINavigationBar的backGroudImage设置为空，然后在UINavigationBar上通过runtime插入一个UIView，然后监听滚动事件，调整这个UIView的透明度来达到这个效果，下面贴代码：123456789101112131415161718192021222324252627282930313233343536 /** 给UINavigationBar添加背景色，用runtime插入一个backView - parameter color: backView的背景颜色 - returns: 返回UINavigationBar本身 */func setWclBackGroundColor(color:UIColor) -&gt; UINavigationBar &#123; let wclBackGroundColorView = objc_getAssociatedObject(self, &amp;wclBackView) as? UIView if wclBackGroundColorView == nil &#123; setBackgroundImage(UIImage.init(), forBarMetrics: .Default) shadowImage = UIImage.init() let backView = UIView.init(frame: CGRectMake(0, -20, bounds.width, bounds.height+20)) backView.backgroundColor = color backView.userInteractionEnabled = false backView.autoresizingMask = [.FlexibleHeight, .FlexibleWidth] insertSubview(backView, atIndex: 0) objc_setAssociatedObject(self, &amp;wclBackView, backView, .OBJC_ASSOCIATION_RETAIN_NONATOMIC) &#125;else &#123; wclBackGroundColorView!.backgroundColor = color &#125; return self&#125;/** 设置backView的透明度 - parameter alpha: backView的透明度 - returns: 返回UINavigationBar本身 */func setWclBackViewAlpha(alpha:CGFloat) -&gt; UINavigationBar &#123; let wclBackGroundColorView = objc_getAssociatedObject(self, &amp;wclBackView) as? UIView wclBackGroundColorView?.alpha = alpha return self&#125; 第二种让UINavigationBar向上位移，并且UINavigationBar上的view透明渐变 主要思路也是通过扩展实现，通过改变UINavigationBar的transform来达到位移的效果，然后通过KVC来获取到UINavigationBar上的subViews来达到它的子view的透明渐变效果，下面上代码： 1234567891011121314151617181920212223242526272829/** 向上隐藏NavigationBar - parameter progress: 隐藏的进度，默认是0，范围0~1 - returns: 返回UINavigationBar本身 */func setWclNavBarHide(progress:CGFloat) -&gt; UINavigationBar &#123; print(progress) if progress &gt; 0 &#123; transform = CGAffineTransformTranslate(CGAffineTransformIdentity, 0, -bounds.height*progress) &#125;else &#123; transform = CGAffineTransformTranslate(CGAffineTransformIdentity, 0, 0) &#125; if let leftViews = valueForKey("_leftViews") as? [UIView] &#123; for leftView in leftViews &#123; leftView.alpha = 1 - progress &#125; &#125; if let rightViews = valueForKey("_rightViews") as? [UIView] &#123; for rightView in rightViews &#123; rightView.alpha = 1 - progress &#125; &#125; if let titleView = valueForKey("_titleView") as? UIView &#123; titleView.alpha = 1 - progress &#125; return self&#125; 第三种UINavigationBar和window的状态栏一起向上位移 主要思路也是通过扩展实现，通过改变UINavigationBar的transform来达到位移的效果，然后通过KVC来获取window的状态栏一起进行偏移，下面上代码： 1234567891011121314151617181920/** 向上隐藏NavigationBar和StateView - parameter progress: 隐藏的进度，默认是0，范围0~1 - returns: 返回UINavigationBar本身 */func setWclNavBarAndStateHide(progress:CGFloat) -&gt; UINavigationBar &#123; if let stateView = UIApplication.sharedApplication().valueForKey("statusBarWindow") as? UIView &#123; if progress &gt; 0 &#123; transform = CGAffineTransformTranslate(CGAffineTransformIdentity, 0, -(bounds.height+20)*progress) stateView.transform = CGAffineTransformTranslate(CGAffineTransformIdentity, 0, -(bounds.height+20)*progress) &#125;else &#123; transform = CGAffineTransformTranslate(CGAffineTransformIdentity, 0, 0) stateView.transform = CGAffineTransformTranslate(CGAffineTransformIdentity, 0, 0) &#125; &#125; return self&#125; demo地址 参考文档 以上就是我总结的关于三种隐藏UINavigationBar的三种发送，欢迎大家一起交流，如果有更好的可以一起学习 作者 @W_C__L2016 年 07月 28日]]></content>
      <categories>
        <category>iOS开发进阶</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GCD深入学习之GCD的初识]]></title>
    <url>%2F2016%2F06%2F27%2FGCD%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E4%B9%8BGCD%E7%9A%84%E5%88%9D%E8%AF%86%2F</url>
    <content type="text"><![CDATA[现在网上关于GCD的介绍已经很多了，在项目中也经常用到，但是没怎么深入研究过，打算写一系列关于GCD使用，参考其他大神写的博客和Apple的技术文档总结一下，一是自己深入学习一下，二是以后忘了可以回过头来温习一下~ 什么是GCD?GCD全名是Grand Central Dispatch（大中央调度器），是系统级的，存在于libdispatch.dylib这个库里，是Apple开发的一个多核编程的解决方法，它提供了一下几种好处： GCD用纯C编写，可以提高应用程序的响应能力，更加高效； GCD使用简单，会自动利用更多的CPU内核（比如双核、四核），自动管理线程的生命周期（创建线程、调度任务、销毁线程），程序员只需要告诉GCD想要执行什么任务，不需要编写任何线程管理代码，提供更容易并发模型，有助于避免并发错误。 GCD的相关术语要了解GCD，你必须熟悉相关的线程和并发的几个概念。这些既可以是模糊的，微妙的，所以花点时间在GCD的背景下简要回顾一下他们。 串行和并发在执行任务时，串行是任务顺序执行，执行完一个下一个。并发就是任务可能同时执行多个任务。在GCD中一个任务就是一个闭包，这比NSOperation中的任务更加容易理解。 同步和异步在计算机领域，同步就是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去；异步是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率。 临界区通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。在任意时刻只允许一个线程对共享资源进行访问，如果有多个线程试图访问公共资 源，那么在有一个线程进入后，其他试图访问公共资源的线程将被挂起，并一直等到进入临界区的线程离开，临界区在被释放后，其他线程才可以抢占。 死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程，简单来说就是A线程在等待B线程完成后执行，B线程也在等待A线程完成后执行，这样就出现了死锁的现象。 线程安全线程安全的代码可以从多个线程或并发任务安全地调用，而不会造成任何问题（数据损坏，系统崩溃等）。例如当你多线程编程时，你用let定义一个数组，因为它是只读的，你能在同一时间不同线程去使用它，而不会造成线程安全的问题，然而当你用var定义一个数组时就不一样了，它不是线程安全的，当多个线程在同一时间访问和修改数组时会产生不可预知的结果。 上下文切换上下文切换是存储和恢复执行的状态，是你在一个进程中执行不同的线程之间切换的过程。这个过程是编写多任务处理应用程序时很常见，但也带来了一些额外的开销成本。就像并发就是通过切换上下文来实现的。 并发和并行在多核设备上执行任务时，每个CPU可以单独工作，每个CPU同时执行不同的任务，这就是并行，然而为了使单核的设备实现这种效果达到类似的效果，应为它们只有一个线程，它们只能通过快速的上下文切换来达到并行的假象，这就是并发，如下图所示： GCD队列GCD用dispatch queues来处理提交的任务，队列用来FIFO（先进先出）的原理来管理这些任务，所有的dispatch queues本身是线程安全的，你可以从多个线程去访问它们，在GCD 中提供了两种队列，分别是串行队列和并发队列。 串行队列串行队列保证同一时间队列里只有一个任务在执行，只有等待第一个任务执行完成后才会执行下一个任务，你也不知道两个任务之间的间隔时间是多少，如下图所示： 使用串行队列有一下的优点： 能确保对一个共享资源进行串行化的访问，避免了数据竞争； 任务的执行顺序是可预知的，你向一个串行队列提交任务时，它们被执行的顺 序与它们被提交的顺序相同； 并发队列并发队列可以让你并行的执行多个任务。任务按照它们被加入到队列中的顺序依次开始，但是它们都是并发的被执行，并不需要彼此等待才开始。并发队列能保证任务按同一顺序开始，但你不能知道执行的顺序、执行的时间以及在某一时刻正在被执行任务的数量，具体如下图所示： GCD 的队列类型在使用过程中系统会自动给每个应用提供一个串行队列和四个并发队列，其中串行队列为全局可用的串行队列，在应用的主线程中执行任务且只有一个，这个队列被用来更新 App 的 UI，执行所有与更新 UIViews 相关的任务。该队列中同一时刻只执行一个任务，这就是为什么当你在主队列中运行一个繁重的任务时UI会被阻塞的原因。GCD提供了一下三种队列： 主队列：任务以串行的方式执行在您的应用程序的主线程； 并发队列：任务在先进先出的顺序列中移除,但并发运行,可以按照任何顺序完成； 串行队列：以先进先出顺序执行一次任务。 除主队列之外，系统还提供了4个并发队列。我们管它们叫 Global Dispatch queues（全局派发队列）。这些队列对整个应用来说是全局可用的，彼此只有优先级高低的区别。要使用其中一个全局并发队列的话，你得使用 dispatch_get_global_queue 函数获得一个你想要的队列的引用，该函数的第一个参数取如下值： DISPATCH_QUEUE_PRIORITY_HIGH：高优先级的队列，高于其他任务优先级的队列。 DISPATCH_QUEUE_PRIORITY_DEFAULT：默认优先级队列，高于下面两个优先级， DISPATCH_QUEUE_PRIORITY_LOW：低优先级队列，低于上面两个优先级。 DISPATCH_QUEUE_PRIORITY_BACKGROUND：最低的优先级，使用它可以尽可能的减少对系统的影响。 你可以创建任何数量的串行或并发队列。使用并发队列的情况下，即使你可以自己创建，但是还是强烈建议你使用上面那四个全局队列，避免带来没必要的麻烦。 创建和管理GCD队列dispatch_get_main_queue() -&gt; dispatch_queue_t!返回值通过这个函数来获取主线程队列： 12//返回主线程队列dispatch_get_main_queue() dispatch_get_globalqueue(identifier: Int, flags: UInt) -&gt; dispatch_queue_t!返回值通过这个函数来获取系统提供的4个并发队列 参数列表 参数名 参数描述 identifier 代表的队列的优先级，为DISPATCH_QUEUE_PRIORITY_HIGH、DISPATCH_QUEUE_PRIORITY_DEFAULT、DISPATCH_QUEUE_PRIORITY_LOW、DISPATCH_QUEUE_PRIORITY_BACKGROUND中的一个 flags 苹果官方解释是保留已提供将来使用，目前让这个参数为0 12345678//返回DISPATCH_QUEUE_PRIORITY_HIGH优先级的队列dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0)//返回DISPATCH_QUEUE_PRIORITY_DEFAULT优先级的队列dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)//返回DISPATCH_QUEUE_PRIORITY_LOW优先级的队列dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0)//返回DISPATCH_QUEUE_PRIORITY_BACKGROUND优先级的队列dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0) dispatch_queuecreate(label: UnsafePointer, attr: dispatch_queue_attr_t!) -&gt; dispatch_queue_t!返回值通过这函数来创建一个新的队列。 参数列表 参数 参数描述 label 为你创建的队列的标签，建议用反向DNS的命名风格（com.example.myqueue），这个参数是可选的，可以为NULL。 attr GCD队列的属性，这个参数来选择创建的是串行队列（DISPATCH_QUEUE_SERIAL）还是并发队列（DISPATCH_QUEUE_CONCURRENT）和队列的优先级别。 1234//创建一个标识为com.wcl.www的并发队列dispatch_queue_create("com.wcl.www", DISPATCH_QUEUE_CONCURRENT)//创建一个标识为com.imwcl.www的串行队列dispatch_queue_create("com.imwcl.www", DISPATCH_QUEUE_SERIAL) dispatch_get_current_queue（）返回值返回当前任务中的队列。 dispatch_queue_attr_make_with_qos_class(attr: dispatch_queue_attrt!, qos_class: dispatch_qos_classt, relative_priority: Int32) -&gt; dispatch_queue_attr_t!返回值返回一个适用于创建一个想要的服务质量信息的GCD队列的属性。主要用于dispatch_queue_create函数。 参数列表 参数 参数描述 attr GCD队列的属性，这个参数来选择创建的是串行队列（DISPATCH_QUEUE_SERIAL）还是并发队列（DISPATCH_QUEUE_CONCURRENT）和队列的优先级别。 qos_class 这个参数为队列优先级，同样为DISPATCH_QUEUE_PRIORITY_HIGH、DISPATCH_QUEUE_PRIORITY_DEFAULT、DISPATCH_QUEUE_PRIORITY_LOW、DISPATCH_QUEUE_PRIORITY_BACKGROUND中的一个。 relative_priority 这个参数为QOS类中相对优先级，这个值必须小于0，大于QOS_MIN_RELATIVE_PRIORITY，根据log数据发现QOS_MIN_RELATIVE_PRIORITY的值为-15，那说明第二个参数的值在0~-15之间。 第三个参数为QOS类中相对优先级，也就是第二个参数的类，这个值必须小于0，大于QOS_MIN_RELATIVE_PRIORITY。 global queue优先级映射到以下quality-of-service类: DISPATCH_QUEUE_PRIORITY_HIG映射到QOS_CLASS_USER_INITIATED。 DISPATCH_QUEUE_PRIORITY_DEFAULT映射到QOS_CLASS_DEFAULT DISPATCH_QUEUE_PRIORITY_LOW映射到QOS_CLASS_UTILITY DISPATCH_QUEUE_PRIORITY_BACKGROUND映射到QOS_CLASS_BACKGROUND 123let att = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_SERIAL, QOS_CLASS_DEFAULT, QOS_MIN_RELATIVE_PRIORITY)//根据att来创建一个队列dispatch_queue_create("com.wcl.www", att) dispatch_queue_get_label(dispatch_queue_t queue)返回值返回已经创建队列的指定标签。如果队列在创建过程中没有提供标签，则可能返回NULL。 12//返回队列的标签dispatch_queue_get_label(dispatch_get_main_queue()) dispatch_main( void)执行主队列上被提交的所有block。这个函数是为主线程而存在的并且等待执行提交到主队列中的block。在主线程中调用了UIApplicationMain(iOS) ，NSApplicationMain(OS X)，或者CFrunLoopRun的应用程序一定不要调用dispatch_main。 1234567891011121314int main(int argc, const charchar * argv[]) &#123; @autoreleasepool &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; NSLog(@&quot;等待1。。。。&quot;); &#125;); dispatch_async(dispatch_get_main_queue(), ^&#123; NSLog(@&quot;等待1。。。。&quot;); &#125;); dispatch_main(); &#125; return 0; &#125; 如上：如果不调用dispatch_main()函数，则不会打印出结果。 dispatch_set_target_queue(object: dispatch_objectt!, queue: dispatch_queue_t!)参数列表 参数 参数描述 object 要修改的对象，该参数不能为空。 queue 处理这个对象的目标队列，这个参数不能为NULL 给GCD对象设置目标队列，这个目标队列负责处理这个对象。处理的对象分别有一下几种： GCD队列：dispatch_queue_t，一个GCD队列的优先级是继承自它的目标队列的。使用dispatch_get_global_queue函数去获得一个合适的目标队列，这个目标队列就是你所需的优先级。 如果你提交一个block到一个串行队列中，并且这个串行队列的目标队列是一个不同的串行队列，那么这个block将不会与其他被提交到这个目标队列的block或者任何其他有相同目标队列的队列同时调用。 GCD数据源：dispatch_source_t，为一个GCD数据源的目标队列指定了它的事件处理者的block和取消事件处理的block。 GCD I/O通道：dispatch_io_t，一个GCD I/O通道的目标队列指定了被执行的I/O操作。这可能会影响I/O操作结果的优先级。例如，如果这个通道的目标队列的优先级被设置为DISPATCH_QUEUE_PRIORITY_BACKGROUND，那么当有I/O操作争夺的时候，任何在这个队列上通过dispatch_io_read或dispatch_io_write执行的I/O操作都会被压制。 关于dispatch_source_t和dispatch_io_t的用法会在以后的章节去介绍。 总结：这篇文章主要详细的介绍了一下关于多线程的知识和GCD队列的的创建，关于GCD的用法和其他方面的知识会在后续文章里面去描述，给自己立一个flag，争取完全弄懂以后写出好的博客来。 参考文档苹果官方GCD参考文档 国外一篇好的关于GCD的文档 作者 @W_C__L2016 年 06月 27日]]></content>
      <categories>
        <category>GCD深入学习</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发进阶 - CAKeyframeAnimation实现过山车动画]]></title>
    <url>%2F2016%2F06%2F22%2FiOS%E5%BC%80%E5%8F%91%E8%BF%9B%E9%98%B6%20-%20CAKeyframeAnimation%E5%AE%9E%E7%8E%B0%E8%BF%87%E5%B1%B1%E8%BD%A6%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[偶然间在网页上看到一个过山车动画觉得很炫，就想用swift纯代码实现了一个类似的效果，因为没有设计天赋，所以就完全高仿的人家的效果-.-下面上效果图： 给大家介绍一下项目中主要会用到的类： CAShapeLayer CAGradientLayer CAKeyframeAnimation 实现的主要思路渐变的背景用CAGradientLayer实现，其他例如山峰，草坪和轨道可以用CAShapeLayer配合UIBezierPath实现，然后云朵，树木和大地直接用CALayer通过设置contents实现，然后云朵和过山车的动画实现用CAKeyframeAnimation，这样分析其实做一个这样的动态效果并不是很难，下面就是实现过程和简单的代码示例。下载demo有完整代码 CAGradientLayerCAGradientLayer是用来生成两种或更多颜色平滑渐变的。相比于Core Graphics来说CAGradientLayer的真正好处在于绘制使用了硬件加速。这说明通过CAGradientLayer来绘制渐变的效果比用Core Graphics的效率更高。我们通过CAGradientLayer来实现这个项目中的背景下载demo有完整代码： 123456789101112//初始化背景 func initGradientLayer(size:CGSize) -&gt; CAGradientLayer &#123; let layer:CAGradientLayer = CAGradientLayer() layer.frame = CGRect(x: 0, y: 0, width: size.width, height: size.height - 20) //设置渐变的颜色 layer.colors = [UIColor.init(colorLiteralRed: 178.0/255.0, green: 226.0/255.0, blue: 248.0/255.0, alpha: 1.0).CGColor, UIColor.init(colorLiteralRed: 232.0/255.0, green: 244.0/255.0, blue: 193.0/255.0, alpha: 1.0).CGColor] //设置渐变的方向为从左上到右下 layer.startPoint = CGPoint(x: 0, y: 0) layer.endPoint = CGPoint(x: 1, y: 1) view.layer.addSublayer(layer) return layer &#125; CAShapeLayerCAShapeLayer是一个通过矢量图形而不是bitmap来绘制的图层子类。你指定诸如颜色和线宽等属性，用CGPath来定义想要绘制的图形，最后CAShapeLayer就自动渲染出来了。当然，你也可以用Core Graphics直接向原始的CALyer的内容中绘制一个路径，相比直下，使用CAShapeLayer有以下一些优点： 渲染快速。CAShapeLayer使用了硬件加速，绘制同一图形会比用Core Graphics快很多。 高效使用内存。一个CAShapeLayer不需要像普通CALayer一样创建一个寄宿图形，所以无论有多大，都不会占用太多的内存。 不会被图层边界剪裁掉。一个CAShapeLayer可以在边界之外绘制。你的图层路径不会像在使用Core Graphics的普通CALayer一样被剪裁掉（如我们在第二章所见）。 不会出现像素化。当你给CAShapeLayer做3D变换时，它不像一个有寄宿图的普通图层一样变得像素化。 我们用CAShapeLayer来绘制草地，山坡和过山车的轨道，下面给大家通过绘制草坪的代码简单介绍一下用法下载demo有完整代码： 12345678910111213//初始化草坪 func initGrasslandlayer(size:CGSize) -&gt; CAShapeLayer &#123; let grasslandOne = CAShapeLayer() //通过UIBezierPath来绘制路径 let pathOne:UIBezierPath = UIBezierPath() pathOne.moveToPoint(CGPoint(x: 0, y: size.height - 20)) pathOne.addLineToPoint(CGPoint(x: 0, y: size.height - 100)) pathOne.addQuadCurveToPoint(CGPoint(x: size.width/3.0, y: size.height - 20), controlPoint: CGPoint(x: size.width/6.0, y: size.height - 100)) grasslandOne.path = pathOne.CGPath //设置草坪的颜色 grasslandOne.fillColor = UIColor.init(colorLiteralRed: 82.0/255.0, green: 177.0/255.0, blue: 44.0/255.0, alpha: 1.0).CGColor view.layer.addSublayer(grasslandOne) &#125; CAKeyframeAnimationCAKeyframeAnimation类为对象提供了关键帧动画的功能。你创建一个CAKeyframeAnimation对象使用animationWithKeyPath:指定属性的关键路径，你可以指定要使用关键帧的值来控制时间和动画的行为。我们可以通过CAKeyframeAnimation来实现过山车在轨道上的的动画和云朵的动画，下面是一小段示例代码下载demo有完整代码： 12345678910111213141516171819202122232425262728293031323334//添加绿色轨道的动画 func addGreenCarPathAnimation(size:CGSize) &#123; let carLayer:CALayer = CALayer() carLayer.frame = CGRect(x: 0, y: 0, width: 17, height: 11) carLayer.contents = UIImage.init(named: "otherCar")!.CGImage //绘制路径 let path:UIBezierPath = UIBezierPath() path.lineCapStyle = .Round path.lineJoinStyle = .Round path.moveToPoint(CGPoint(x: size.width + 10, y: size.height - 7)) path.addLineToPoint(CGPoint(x: size.width + 10, y: size.height - 77)) path.addQuadCurveToPoint(CGPoint(x: size.width/1.8, y: size.height - 77), controlPoint: CGPoint(x: size.width - 120, y: 193)) path.addArcWithCenter(CGPoint(x: size.width/1.9, y: size.height - 140), radius: 63, startAngle: CGFloat(0.5*M_PI), endAngle: CGFloat(2.5*M_PI), clockwise: true) path.addCurveToPoint(CGPoint(x: 0, y: size.height - 107), controlPoint1: CGPoint(x: size.width/1.8 - 60, y: size.height - 67), controlPoint2: CGPoint(x: 150, y: size.height/2.3-7)) path.addLineToPoint(CGPoint(x: -100, y: size.height + 7)) //关键帧动画作用于position let animation:CAKeyframeAnimation = CAKeyframeAnimation.init(keyPath: "position") animation.path = path.CGPath //动画节奏为线性动画 animation.timingFunction = CAMediaTimingFunction.init(name: kCAMediaTimingFunctionLinear) //动画时间 animation.duration = 6 //动画重复次数 animation.repeatCount = MAXFLOAT //动画是否逆转 animation.autoreverses = false animation.calculationMode = kCAAnimationCubicPaced //动画角度是否调整 animation.rotationMode = kCAAnimationRotateAuto view.layer.addSublayer(carLayer) carLayer.addAnimation(animation, forKey: "carAnimation") &#125; 上面的代码只是简单的示例，完整代码得去我的github上去下载，到这里也就基本上完成了，大家有什么疑问可以留言评论，谢谢大家的观看 demo地址 参考文档（非常好的一篇关于介绍CALayer学习中文翻译文档，学习必看） 作者 @W_C__L2016 年 06月 22日]]></content>
      <categories>
        <category>iOS动画进阶</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发进阶 - 实现类似微信和支付宝的密码输入框（UIKeyInput协议）]]></title>
    <url>%2F2016%2F06%2F02%2FiOS%E5%BC%80%E5%8F%91%E8%BF%9B%E9%98%B6-%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%BC%BC%E5%BE%AE%E4%BF%A1%E5%92%8C%E6%94%AF%E4%BB%98%E5%AE%9D%E7%9A%84%E5%AF%86%E7%A0%81%E8%BE%93%E5%85%A5%E6%A1%86%EF%BC%88UIKeyInput%E5%8D%8F%E8%AE%AE%EF%BC%89%2F</url>
    <content type="text"><![CDATA[目前在项目中需要实现发红包的功能，自己就写了一个密码输入框的控件，主要用到了UIKeyInput协议和CoreGraphics框架，效果类似微信支付，感觉还行就把我的思路和制作过程写下来给大家分享一下。（demo地址觉得有用的可以star一下） 让你的自定义View具备输入的功能（UIKeyInput协议）通过UIKeyInput协议可以为响应者提供简单的键盘输入的功能，让需要键盘的responder成为第一响应者就行了。UIKeyInput协议必须实现的有三个方法，分别是以下方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#pragma mark - UIKeyInput/** * 用于显示的文本对象是否有任何文本 */- (BOOL)hasText &#123; return self.textStore.length &gt; 0;&#125;/** * 插入文本 */- (void)insertText:(NSString *)text &#123; if (self.textStore.length &lt; self.passWordNum) &#123; //判断是否是数字 NSCharacterSet *cs = [[NSCharacterSet characterSetWithCharactersInString:MONEYNUMBERS] invertedSet]; NSString*filtered = [[text componentsSeparatedByCharactersInSet:cs] componentsJoinedByString:@&quot;&quot;]; BOOL basicTest = [text isEqualToString:filtered]; if(basicTest) &#123; if ([self.delegate respondsToSelector:@selector(passWordDidChange:)]) &#123; [self.delegate passWordDidChange:self]; &#125; if (self.textStore.length == self.passWordNum) &#123; if ([self.delegate respondsToSelector:@selector(passWordCompleteInput:)]) &#123; [self.delegate passWordCompleteInput:self]; &#125; &#125; [self.textStore appendString:text]; [self setNeedsDisplay]; &#125; &#125;&#125;/** * 删除文本 */- (void)deleteBackward &#123; if (self.textStore.length &gt; 0) &#123; [self.textStore deleteCharactersInRange:NSMakeRange(self.textStore.length - 1, 1)]; if ([self.delegate respondsToSelector:@selector(passWordDidChange:)]) &#123; [self.delegate passWordDidChange:self]; &#125; &#125; [self setNeedsDisplay];&#125;/** * 是否能成为第一响应者 */- (BOOL)canBecomeFirstResponder &#123; return YES;&#125;/** * 点击成为第一相应者 */- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; if (![self isFirstResponder]) &#123; [self becomeFirstResponder]; &#125;&#125; 实现类似微信和支付宝的密码输入框实现的思路是通过CoreGraphics框架绘制出密码输入框的外框和里面的小黑点，然后通过从键盘上获取到的字符串判断输入的位数，具体实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * 设置正方形的边长 */- (void)setSquareWidth:(CGFloat)squareWidth &#123; _squareWidth = squareWidth; [self setNeedsDisplay];&#125;/** * 设置键盘的类型 */- (UIKeyboardType)keyboardType &#123; return UIKeyboardTypeNumberPad;&#125;/** * 设置密码的位数 */- (void)setPassWordNum:(NSUInteger)passWordNum &#123; _passWordNum = passWordNum; [self setNeedsDisplay];&#125;/** * 绘制 */- (void)drawRect:(CGRect)rect &#123; CGFloat height = rect.size.height; CGFloat width = rect.size.width; CGFloat x = (width - self.squareWidth*self.passWordNum)/2.0; CGFloat y = (height - self.squareWidth)/2.0; CGContextRef context = UIGraphicsGetCurrentContext(); //画外框 CGContextAddRect(context, CGRectMake( x, y, self.squareWidth*self.passWordNum, self.squareWidth)); CGContextSetLineWidth(context, 1); CGContextSetStrokeColorWithColor(context, self.rectColor.CGColor); CGContextSetFillColorWithColor(context, [UIColor whiteColor].CGColor); //画竖条 for (int i = 1; i &lt;= self.passWordNum; i++) &#123; CGContextMoveToPoint(context, x+i*self.squareWidth, y); CGContextAddLineToPoint(context, x+i*self.squareWidth, y+self.squareWidth); CGContextClosePath(context); &#125; CGContextDrawPath(context, kCGPathFillStroke); CGContextSetFillColorWithColor(context, self.pointColor.CGColor); //画黑点 for (int i = 1; i &lt;= self.textStore.length; i++) &#123; CGContextAddArc(context, x+i*self.squareWidth - self.squareWidth/2.0, y+self.squareWidth/2, self.pointRadius, 0, M_PI*2, YES); CGContextDrawPath(context, kCGPathFill); &#125;&#125; 以上就是实现的主要代码和分析，大家需要看demo可以点击超链接进去下载观看，谢谢大家的阅读~ 作者 @W_C__L2016 年 06月 02日]]></content>
      <categories>
        <category>iOS开发进阶</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发进阶 - 用AVFoundation自定义视频录制功能]]></title>
    <url>%2F2016%2F05%2F25%2FiOS%E5%BC%80%E5%8F%91%E8%BF%9B%E9%98%B6%20-%20%E7%94%A8AVFoundation%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[系统自带的录制视频的功能显然无法满足美工和项目经理的要求，自定义视频录制就非常重要了，那么下面来带大家制作属于自己的视频录制界面。 简介自定义视频录制需要用到的框架主要是AVFoundation和CoreMedia，包括视频输出，输入和文件的读写，下面给大家罗列一下将要用到的类： AVCaptureSession AVCaptureVideoPreviewLayer AVCaptureDeviceInput AVCaptureConnection AVCaptureVideoDataOutput AVCaptureAudioDataOutput AVAssetWriter AVAssetWriterInput 下面详细介绍每个类和代码实现 AVCaptureSessionAVCaptureSession是AVFoundation捕捉类的中心枢纽，我们先从这个类入手，在视频捕获时,客户端可以实例化AVCaptureSession并添加适当的AVCaptureInputs、AVCaptureDeviceInput和输出，比如AVCaptureMovieFileOutput。通过[AVCaptureSession startRunning]开始数据流从输入到输出,和[AVCaptureSession stopRunning]停止输出输入的流动。客户端可以通过设置sessionPreset属性定制录制质量水平或输出的比特率。 1234567891011121314151617181920212223242526272829//捕获视频的会话- (AVCaptureSession *)recordSession &#123; if (_recordSession == nil) &#123; _recordSession = [[AVCaptureSession alloc] init]; //添加后置摄像头的输出 if ([_recordSession canAddInput:self.backCameraInput]) &#123; [_recordSession addInput:self.backCameraInput]; &#125; //添加后置麦克风的输出 if ([_recordSession canAddInput:self.audioMicInput]) &#123; [_recordSession addInput:self.audioMicInput]; &#125; //添加视频输出 if ([_recordSession canAddOutput:self.videoOutput]) &#123; [_recordSession addOutput:self.videoOutput]; //设置视频的分辨率为后置摄像头 NSDictionary* actual = self.videoOutput.videoSettings; _cx = [[actual objectForKey:@&quot;Height&quot;] integerValue]; _cy = [[actual objectForKey:@&quot;Width&quot;] integerValue]; &#125; //添加音频输出 if ([_recordSession canAddOutput:self.audioOutput]) &#123; [_recordSession addOutput:self.audioOutput]; &#125; //设置视频录制的方向 self.videoConnection.videoOrientation = AVCaptureVideoOrientationPortrait; &#125; return _recordSession;&#125; AVCaptureDeviceAVCaptureDevice的每个实例对应一个设备,如摄像头或麦克风。AVCaptureDevice的实例不能直接创建。所有现有设备可以使用类方法devicesWithMediaType:defaultDeviceWithMediaType:获取，设备可以提供一个或多个给定流媒体类型。AVCaptureDevice实例可用于提供给AVCaptureSession创建一个为AVCaptureDeviceInput类型的输入源。 123456789101112131415161718192021222324252627282930313233343536373839404142//返回前置摄像头- (AVCaptureDevice *)frontCamera &#123; return [self cameraWithPosition:AVCaptureDevicePositionFront];&#125;//返回后置摄像头- (AVCaptureDevice *)backCamera &#123; return [self cameraWithPosition:AVCaptureDevicePositionBack];&#125;//用来返回是前置摄像头还是后置摄像头- (AVCaptureDevice *)cameraWithPosition:(AVCaptureDevicePosition) position &#123; //返回和视频录制相关的所有默认设备 NSArray *devices = [AVCaptureDevice devicesWithMediaType:AVMediaTypeVideo]; //遍历这些设备返回跟position相关的设备 for (AVCaptureDevice *device in devices) &#123; if ([device position] == position) &#123; return device; &#125; &#125; return nil;&#125;//开启闪光灯- (void)openFlashLight &#123; AVCaptureDevice *backCamera = [self backCamera]; if (backCamera.torchMode == AVCaptureTorchModeOff) &#123; [backCamera lockForConfiguration:nil]; backCamera.torchMode = AVCaptureTorchModeOn; backCamera.flashMode = AVCaptureFlashModeOn; [backCamera unlockForConfiguration]; &#125;&#125;//关闭闪光灯- (void)closeFlashLight &#123; AVCaptureDevice *backCamera = [self backCamera]; if (backCamera.torchMode == AVCaptureTorchModeOn) &#123; [backCamera lockForConfiguration:nil]; backCamera.torchMode = AVCaptureTorchModeOff; backCamera.flashMode = AVCaptureTorchModeOff; [backCamera unlockForConfiguration]; &#125;&#125; AVCaptureDeviceInputAVCaptureDeviceInput 是AVCaptureSession输入源,提供媒体数据从设备连接到系统，通过AVCaptureDevice的实例化得到，就是我们将要用到的设备输出源设备，也就是前后摄像头，通过[AVCaptureDevice devicesWithMediaType:AVMediaTypeVideo]方法获得。 1234567891011121314151617181920212223//后置摄像头输入- (AVCaptureDeviceInput *)backCameraInput &#123; if (_backCameraInput == nil) &#123; NSError *error; _backCameraInput = [[AVCaptureDeviceInput alloc] initWithDevice:[self backCamera] error:&amp;error]; if (error) &#123; [SVProgressHUD showErrorWithStatus:@&quot;获取后置摄像头失败~&quot;]; &#125; &#125; return _backCameraInput;&#125;//前置摄像头输入- (AVCaptureDeviceInput *)frontCameraInput &#123; if (_frontCameraInput == nil) &#123; NSError *error; _frontCameraInput = [[AVCaptureDeviceInput alloc] initWithDevice:[self frontCamera] error:&amp;error]; if (error) &#123; [SVProgressHUD showErrorWithStatus:@&quot;获取前置摄像头失败~&quot;]; &#125; &#125; return _frontCameraInput;&#125; AVCaptureVideoPreviewLayer是CoreAnimation里面layer的一个子类，用来做为AVCaptureSession预览视频输出，简单来说就是来做为拍摄的视频呈现的一个layer。 1234567891011//捕获到的视频呈现的layer- (AVCaptureVideoPreviewLayer *)previewLayer &#123; if (_previewLayer == nil) &#123; //通过AVCaptureSession初始化 AVCaptureVideoPreviewLayer *preview = [[AVCaptureVideoPreviewLayer alloc] initWithSession:self.recordSession]; //设置比例为铺满全屏 preview.videoGravity = AVLayerVideoGravityResizeAspectFill; _previewLayer = preview; &#125; return _previewLayer;&#125; AVCaptureMovieFileOutputAVCaptureMovieFileOutput是AVCaptureFileOutput的子类，用来写入QuickTime视频类型的媒体文件。因为这个类在iphone上并不能实现暂停录制，和不能定义视频文件的类型，所以在这里并不使用，而是用灵活性更强的AVCaptureVideoDataOutput和AVCaptureAudioDataOutput来实现视频的录制。 AVCaptureVideoDataOutputAVCaptureVideoDataOutput是AVCaptureOutput一个子类，可以用于用来输出未压缩或压缩的视频捕获的帧，AVCaptureVideoDataOutput产生的实例可以使用其他媒体视频帧适合的api处理，应用程序可以用captureOutput:didOutputSampleBuffer:fromConnection:代理方法来获取帧数据。 123456789101112//视频输出- (AVCaptureVideoDataOutput *)videoOutput &#123; if (_videoOutput == nil) &#123; _videoOutput = [[AVCaptureVideoDataOutput alloc] init]; [_videoOutput setSampleBufferDelegate:self queue:self.captureQueue]; NSDictionary* setcapSettings = [NSDictionary dictionaryWithObjectsAndKeys: [NSNumber numberWithInt:kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange], kCVPixelBufferPixelFormatTypeKey, nil]; _videoOutput.videoSettings = setcapSettings; &#125; return _videoOutput;&#125; AVCaptureAudioDataOutputAVCaptureAudioDataOutput是AVCaptureOutput的子类，可用于用来输出捕获来的非压缩或压缩的音频样本，AVCaptureAudioDataOutput产生的实例可以使用其他媒体视频帧适合的api处理，应用程序可以用captureOutput:didOutputSampleBuffer:fromConnection:代理方法来获取音频数据。 12345678//音频输出- (AVCaptureAudioDataOutput *)audioOutput &#123; if (_audioOutput == nil) &#123; _audioOutput = [[AVCaptureAudioDataOutput alloc] init]; [_audioOutput setSampleBufferDelegate:self queue:self.captureQueue]; &#125; return _audioOutput;&#125; AVCaptureConnectionAVCaptureConnection代表AVCaptureInputPort或端口之间的连接，和一个AVCaptureOutput或AVCaptureVideoPreviewLayer在AVCaptureSession中的呈现。 12345678910111213//视频连接- (AVCaptureConnection *)videoConnection &#123; _videoConnection = [self.videoOutput connectionWithMediaType:AVMediaTypeVideo]; return _videoConnection;&#125;//音频连接- (AVCaptureConnection *)audioConnection &#123; if (_audioConnection == nil) &#123; _audioConnection = [self.audioOutput connectionWithMediaType:AVMediaTypeAudio]; &#125; return _audioConnection;&#125; AVAssetWriterAVAssetWriter为写入媒体数据到一个新的文件提供服务，AVAssetWriter的实例可以规定写入媒体文件的格式，如QuickTime电影文件格式或MPEG-4文件格式等等。AVAssetWriter有多个并行的轨道媒体数据，基本的有视频轨道和音频轨道，将会在下面介绍。AVAssetWriter的单个实例可用于一次写入一个单一的文件。那些希望写入多次文件的客户端必须每一次用一个新的AVAssetWriter实例。 12345678910111213141516171819202122//初始化方法- (instancetype)initPath:(NSString*)path Height:(NSInteger)cy width:(NSInteger)cx channels:(int)ch samples:(Float64) rate &#123; self = [super init]; if (self) &#123; self.path = path; //先把路径下的文件给删除掉，保证录制的文件是最新的 [[NSFileManager defaultManager] removeItemAtPath:self.path error:nil]; NSURL* url = [NSURL fileURLWithPath:self.path]; //初始化写入媒体类型为MP4类型 _writer = [AVAssetWriter assetWriterWithURL:url fileType:AVFileTypeMPEG4 error:nil]; //使其更适合在网络上播放 _writer.shouldOptimizeForNetworkUse = YES; //初始化视频输出 [self initVideoInputHeight:cy width:cx]; //确保采集到rate和ch if (rate != 0 &amp;&amp; ch != 0) &#123; //初始化音频输出 [self initAudioInputChannels:ch samples:rate]; &#125; &#125; return self;&#125; AVAssetWriterInput用AVAssetWriterInput去拼接一个多媒体样本类型为CMSampleBuffer的实例到AVAssetWriter对象的输出文件的一个轨道；当有多个输入时， AVAssetWriter试图在用于存储和播放效率的理想模式写媒体数据。它的每一个输入信号，是否能接受媒体的数据根据通过readyForMoreMediaData的值来判断。如果readyForMoreMediaData是YES ，说明输入可以接受媒体数据。并且你只能媒体数据追加到输入端。 123456789101112131415161718192021222324252627282930313233//初始化视频输入- (void)initVideoInputHeight:(NSInteger)cy width:(NSInteger)cx &#123; //录制视频的一些配置，分辨率，编码方式等等 NSDictionary* settings = [NSDictionary dictionaryWithObjectsAndKeys: AVVideoCodecH264, AVVideoCodecKey, [NSNumber numberWithInteger: cx], AVVideoWidthKey, [NSNumber numberWithInteger: cy], AVVideoHeightKey, nil]; //初始化视频写入类 _videoInput = [AVAssetWriterInput assetWriterInputWithMediaType:AVMediaTypeVideo outputSettings:settings]; //表明输入是否应该调整其处理为实时数据源的数据 _videoInput.expectsMediaDataInRealTime = YES; //将视频输入源加入 [_writer addInput:_videoInput];&#125;//初始化音频输入- (void)initAudioInputChannels:(int)ch samples:(Float64)rate &#123; //音频的一些配置包括音频各种这里为AAC,音频通道、采样率和音频的比特率 NSDictionary *settings = [NSDictionary dictionaryWithObjectsAndKeys: [ NSNumber numberWithInt: kAudioFormatMPEG4AAC], AVFormatIDKey, [ NSNumber numberWithInt: ch], AVNumberOfChannelsKey, [ NSNumber numberWithFloat: rate], AVSampleRateKey, [ NSNumber numberWithInt: 128000], AVEncoderBitRateKey, nil]; //初始化音频写入类 _audioInput = [AVAssetWriterInput assetWriterInputWithMediaType:AVMediaTypeAudio outputSettings:settings]; //表明输入是否应该调整其处理为实时数据源的数据 _audioInput.expectsMediaDataInRealTime = YES; //将音频输入源加入 [_writer addInput:_audioInput]; &#125; 上面是录制之前的一些需要的类和配置，下面介绍的是如何将获取到的数据呈现出来和怎样进行文件写入 写入数据123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#pragma mark - 写入数据- (void) captureOutput:(AVCaptureOutput *)captureOutput didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection *)connection &#123; BOOL isVideo = YES; @synchronized(self) &#123; if (!self.isCapturing || self.isPaused) &#123; return; &#125; if (captureOutput != self.videoOutput) &#123; isVideo = NO; &#125; //初始化编码器，当有音频和视频参数时创建编码器 if ((self.recordEncoder == nil) &amp;&amp; !isVideo) &#123; CMFormatDescriptionRef fmt = CMSampleBufferGetFormatDescription(sampleBuffer); [self setAudioFormat:fmt]; NSString *videoName = [NSString getUploadFile_type:@&quot;video&quot; fileType:@&quot;mp4&quot;]; self.videoPath = [[self getVideoCachePath] stringByAppendingPathComponent:videoName]; self.recordEncoder = [WCLRecordEncoder encoderForPath:self.videoPath Height:_cy width:_cx channels:_channels samples:_samplerate]; &#125; //判断是否中断录制过 if (self.discont) &#123; if (isVideo) &#123; return; &#125; self.discont = NO; // 计算暂停的时间 CMTime pts = CMSampleBufferGetPresentationTimeStamp(sampleBuffer); CMTime last = isVideo ? _lastVideo : _lastAudio; if (last.flags &amp; kCMTimeFlags_Valid) &#123; if (_timeOffset.flags &amp; kCMTimeFlags_Valid) &#123; pts = CMTimeSubtract(pts, _timeOffset); &#125; CMTime offset = CMTimeSubtract(pts, last); if (_timeOffset.value == 0) &#123; _timeOffset = offset; &#125;else &#123; _timeOffset = CMTimeAdd(_timeOffset, offset); &#125; &#125; _lastVideo.flags = 0; _lastAudio.flags = 0; &#125; // 增加sampleBuffer的引用计时,这样我们可以释放这个或修改这个数据，防止在修改时被释放 CFRetain(sampleBuffer); if (_timeOffset.value &gt; 0) &#123; CFRelease(sampleBuffer); //根据得到的timeOffset调整 sampleBuffer = [self adjustTime:sampleBuffer by:_timeOffset]; &#125; // 记录暂停上一次录制的时间 CMTime pts = CMSampleBufferGetPresentationTimeStamp(sampleBuffer); CMTime dur = CMSampleBufferGetDuration(sampleBuffer); if (dur.value &gt; 0) &#123; pts = CMTimeAdd(pts, dur); &#125; if (isVideo) &#123; _lastVideo = pts; &#125;else &#123; _lastAudio = pts; &#125; &#125; CMTime dur = CMSampleBufferGetPresentationTimeStamp(sampleBuffer); if (self.startTime.value == 0) &#123; self.startTime = dur; &#125; CMTime sub = CMTimeSubtract(dur, self.startTime); self.currentRecordTime = CMTimeGetSeconds(sub); if (self.currentRecordTime &gt; self.maxRecordTime) &#123; if (self.currentRecordTime - self.maxRecordTime &lt; 0.1) &#123; if ([self.delegate respondsToSelector:@selector(recordProgress:)]) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; [self.delegate recordProgress:self.currentRecordTime/self.maxRecordTime]; &#125;); &#125; &#125; return; &#125; if ([self.delegate respondsToSelector:@selector(recordProgress:)]) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; [self.delegate recordProgress:self.currentRecordTime/self.maxRecordTime]; &#125;); &#125; // 进行数据编码 [self.recordEncoder encodeFrame:sampleBuffer isVideo:isVideo]; CFRelease(sampleBuffer);&#125;//设置音频格式- (void)setAudioFormat:(CMFormatDescriptionRef)fmt &#123; const AudioStreamBasicDescription *asbd = CMAudioFormatDescriptionGetStreamBasicDescription(fmt); _samplerate = asbd-&gt;mSampleRate; _channels = asbd-&gt;mChannelsPerFrame; &#125;//调整媒体数据的时间- (CMSampleBufferRef)adjustTime:(CMSampleBufferRef)sample by:(CMTime)offset &#123; CMItemCount count; CMSampleBufferGetSampleTimingInfoArray(sample, 0, nil, &amp;count); CMSampleTimingInfo* pInfo = malloc(sizeof(CMSampleTimingInfo) * count); CMSampleBufferGetSampleTimingInfoArray(sample, count, pInfo, &amp;count); for (CMItemCount i = 0; i &lt; count; i++) &#123; pInfo[i].decodeTimeStamp = CMTimeSubtract(pInfo[i].decodeTimeStamp, offset); pInfo[i].presentationTimeStamp = CMTimeSubtract(pInfo[i].presentationTimeStamp, offset); &#125; CMSampleBufferRef sout; CMSampleBufferCreateCopyWithNewTiming(nil, sample, count, pInfo, &amp;sout); free(pInfo); return sout;&#125;//通过这个方法写入数据- (BOOL)encodeFrame:(CMSampleBufferRef) sampleBuffer isVideo:(BOOL)isVideo &#123; //数据是否准备写入 if (CMSampleBufferDataIsReady(sampleBuffer)) &#123; //写入状态为未知,保证视频先写入 if (_writer.status == AVAssetWriterStatusUnknown &amp;&amp; isVideo) &#123; //获取开始写入的CMTime CMTime startTime = CMSampleBufferGetPresentationTimeStamp(sampleBuffer); //开始写入 [_writer startWriting]; [_writer startSessionAtSourceTime:startTime]; &#125; //写入失败 if (_writer.status == AVAssetWriterStatusFailed) &#123; NSLog(@&quot;writer error %@&quot;, _writer.error.localizedDescription); return NO; &#125; //判断是否是视频 if (isVideo) &#123; //视频输入是否准备接受更多的媒体数据 if (_videoInput.readyForMoreMediaData == YES) &#123; //拼接数据 [_videoInput appendSampleBuffer:sampleBuffer]; return YES; &#125; &#125;else &#123; //音频输入是否准备接受更多的媒体数据 if (_audioInput.readyForMoreMediaData) &#123; //拼接数据 [_audioInput appendSampleBuffer:sampleBuffer]; return YES; &#125; &#125; &#125; return NO;&#125; 完成录制并写入相册1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//停止录制- (void) stopCaptureHandler:(void (^)(UIImage *movieImage))handler &#123; @synchronized(self) &#123; if (self.isCapturing) &#123; NSString* path = self.recordEncoder.path; NSURL* url = [NSURL fileURLWithPath:path]; self.isCapturing = NO; dispatch_async(_captureQueue, ^&#123; [self.recordEncoder finishWithCompletionHandler:^&#123; self.isCapturing = NO; self.recordEncoder = nil; [[PHPhotoLibrary sharedPhotoLibrary] performChanges:^&#123; [PHAssetChangeRequest creationRequestForAssetFromVideoAtFileURL:url]; &#125; completionHandler:^(BOOL success, NSError * _Nullable error) &#123; NSLog(@&quot;保存成功&quot;); &#125;]; [self movieToImageHandler:handler]; &#125;]; &#125;); &#125; &#125;&#125;//获取视频第一帧的图片- (void)movieToImageHandler:(void (^)(UIImage *movieImage))handler &#123; NSURL *url = [NSURL fileURLWithPath:self.videoPath]; AVURLAsset *asset = [[AVURLAsset alloc] initWithURL:url options:nil]; AVAssetImageGenerator *generator = [[AVAssetImageGenerator alloc] initWithAsset:asset]; generator.appliesPreferredTrackTransform = TRUE; CMTime thumbTime = CMTimeMakeWithSeconds(0, 60); generator.apertureMode = AVAssetImageGeneratorApertureModeEncodedPixels; AVAssetImageGeneratorCompletionHandler generatorHandler = ^(CMTime requestedTime, CGImageRef im, CMTime actualTime, AVAssetImageGeneratorResult result, NSError *error)&#123; if (result == AVAssetImageGeneratorSucceeded) &#123; UIImage *thumbImg = [UIImage imageWithCGImage:im]; if (handler) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; handler(thumbImg); &#125;); &#125; &#125; &#125;; [generator generateCGImagesAsynchronouslyForTimes: [NSArray arrayWithObject:[NSValue valueWithCMTime:thumbTime]] completionHandler:generatorHandler];&#125;//完成视频录制时调用- (void)finishWithCompletionHandler:(void (^)(void))handler &#123; [_writer finishWritingWithCompletionHandler: handler];&#125; 以上就是本博客内容的全部内容，大家如果有什么疑问可以问我，本文附带有demo，大家可以去看看具体怎么使用，有用的话可以点一下star，谢谢大家的阅读~~ 我的demo地址 作者 @W_C__L2016 年 05月 25日]]></content>
      <categories>
        <category>视频相关</category>
      </categories>
      <tags>
        <tag>AVFoundation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发小结 - 通过PUT请求上传数据]]></title>
    <url>%2F2016%2F05%2F17%2FiOS%E5%BC%80%E5%8F%91-%E9%80%9A%E8%BF%87PUT%E8%AF%B7%E6%B1%82%E4%B8%8A%E4%BC%A0%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[一般服务器上传数据一般都是用POST请求，这样通过AFNetworking的POST请求稳稳的，但是有一天遇到一个问题，服务器上传数据用的是PUT请求，发现用AFNetworking并不是那么好用，今天就来讲一下如何通过PUT请求上传数据。 什么是PUT请求PUT请求是请求服务器存储一个资源，并用Request-URI作为其标识，跟POST类似，但不常用，PUT请求比较少见。HTML表单也不支持这个。本质上来讲， PUT和POST极为相似，都是向服务器发送数据，但它们之间有一个重要区别，PUT通常指定了资源的存放位置，而POST则没有，POST的数据存放位置由服务器自己决定。举个例子：如一个用于提交博文的URL，/addBlog。如果用PUT，则提交的URL会是像这样的”/addBlog/abc123”，其中abc123就是这个博文的地址。而如果用POST，则这个地址会在提交后由服务器告知客户端。目前大部分博客都是这样的。显然，PUT和POST用途是不一样的。具体用哪个还取决于当前的业务场景。 POST和PUT的请求根本区别有的观点认为，应该用POST来创建一个资源，用PUT来更新一个资源；有的观点认为，应该用PUT来创建一个资源，用POST来更新一个资源；还有的观点认为可以用PUT和POST中任何一个来做创建或者更新一个资源。这些观点都只看到了风格，争论起来也只是争论哪种风格更好，其实，用PUT还是POST，不是看这是创建还是更新资源的动作，这不是风格的问题，而是语义的问题。在HTTP中，PUT被定义为idempotent的方法，POST则不是，这是一个很重要的区别。 在代码中如何应用我们先来看看AFNetworking中PUT和POST方法怎么用： 12345678910111213//POST方法- (nullable NSURLSessionDataTask *)POST:(NSString *)URLString parameters:(nullable id)parameters constructingBodyWithBlock:(nullable void (^)(id &lt;AFMultipartFormData&gt; formData))block progress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgress success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure;//PUT方法- (nullable NSURLSessionDataTask *)PUT:(NSString *)URLString parameters:(nullable id)parameters success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure; 发现参数中只有URLString和parameters，相对于POST请求来说少了一个formData的参数，没有地方把数据拼接上去，我曾经尝试把Data放到parameters中并不好用，在网上搜索了很多也没找到合适的解决办法，只能换一种方式了。 解决办法在用AFNetworking进行PUT请求不好用之后，我想过是否用通过系统NSURLSessionTask来实现PUT请求，但是想想自己写太麻烦了，就尝试着用ASIHTTPRequest来尝试一下，发现ASIHTTPRequest还是很好用的，下面贴出代码： 1234567891011121314151617181920- (void)uploadData:(NSData *)data uploadUrl:(NSString *)uploadUrl &#123; ASIHTTPRequest * fileUpRequest = [ASIHTTPRequest requestWithURL:[NSURL URLWithString:uploadUrl]]; fileUpRequest.delegate = self; //设置请求超时时间为60秒 [fileUpRequest setTimeOutSeconds:60.f]; //设置请求超时时间后再次尝试请求的次数 [fileUpRequest setNumberOfTimesToRetryOnTimeout:2]; //将data拼接进去 [fileUpRequest appendPostData:data]; //设置请求方式为PUT [fileUpRequest setRequestMethod:@&quot;PUT&quot;]; //设置上传失败的回调方法 [fileUpRequest setDidFailSelector:@selector(uploadFailed:)]; //设置上传成功的回调方法 [fileUpRequest setDidFinishSelector:@selector(uploadFinished:)]; //显示精确的上传进度 fileUpRequest.showAccurateProgress = YES; //开始异步请求 [fileUpRequest startAsynchronous];&#125; 到这里我的问题已经解决，如果大家还有问题可以给我留言解决，谢谢大家的支持。 我的CSDN博客地址我的GitHub地址 作者 @W_C__L2016 年 05月 17日]]></content>
      <categories>
        <category>iOS开发小结</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发小结 - 使用自定义字体]]></title>
    <url>%2F2016%2F05%2F16%2FiOS%E5%BC%80%E5%8F%91%E5%B0%8F%E7%BB%93%20-%20%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93%2F</url>
    <content type="text"><![CDATA[APP开发过程中，根据美工的需求可能会用到一些特殊的字体，然而在苹果自带字体中并没有，那就必须我们开发来来实现这些功能呢，下面以冬青黑体简体中文(Hiragino Sans GB)为例子给大家演示一下自定义字体的步骤： 首先将下好的字体放到工程里面 然后在info.pilist里面加以下字段 然后就可以使用了，在xib中使用： 用代码使用： 12//大家注意，要把中间的空格都去掉[UIFont fontWithName:@&quot;HiraginoSansGB-W3&quot; size:12] 这样就可以使用自定义字体，不过不建议大家使用，因为汉字字体的包大小很大，会增加应用包的大小，像一套冬青黑体简体中文(Hiragino Sans GB)大小总共有26MB左右，这样增加应用包大小就得不偿失了。 作者 @W_C__L2016 年 05月 16日]]></content>
      <categories>
        <category>iOS开发小结</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发小结 - github SSH秘钥配置]]></title>
    <url>%2F2016%2F04%2F22%2Fgithub-SSH-Configure%2F</url>
    <content type="text"><![CDATA[github SSH秘钥配置从github上clone代码下来，或者关联你的远程仓库有两种链接，一种是Https的链接，一种是ssh的链接，今天要讲的是用ssh链时出现的一些问题和解决办法。 如何创建SSH打开你的终端，输入ssh-keygen -t rsa -C “xxxxx@xxxxx.com”，里面的邮箱是你的github账号，然后会弹出Enter file in which to save the key (/Users/wangchonglei/.ssh/id_rsa):这里是系统默认的保存地址和文件名，你可以更改，例如：/Users/wangchonglei/.ssh/girhub_rsa（记住：不同的账号需要起不一样的名字），然后一直回车会出现类似下面这样的文字，就说明创建成功了； The key’s randomart image is:+—[RSA 2048]—-+| o|| . ..|| o o o .|| o + = = || . . S = o +oo|| E o = + .. =|| + + .+ =.|| . .o BB=|| o=.o. o*O|+—-[SHA256]—–+ 如何查看你的rsa有两种方式可以查看，第一种比较简单，直接cat ~/.ssh/#####.pub，这里是你刚刚自己输入的文件名，系统默认的是id_rsa.pub； 第二种使用vim编辑器查看，首先cd ~/.ssh，到文件目录下，然后vim 你的文件名，比如vim ####.pub就可以查看了。 把你的SSH填写到github上 这个比较简单，在github上点击你的头像，选择setting，进入后点击SSHKEYS后Add SSH key就行了 测试是否设置成功在终端中输入ssh -T git@git.oschina.net，系统返回Welcome to Git@OSC，###是就表示添加成功了，就你可以用git remote add origin git@#####来关联你的远程库了。 作者 @W_C__L2016 年 04月 22日]]></content>
      <categories>
        <category>iOS开发小结</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发进阶 - 常用的Xcode插件]]></title>
    <url>%2F2016%2F04%2F22%2FXcode-Plug-In%2F</url>
    <content type="text"><![CDATA[Alcatraz - 插件管理工具Alcatraz是一个开源的Xcode插件管理器，可以让你更便捷地发现、安装以及管理插件、模板和配色方案。只需要简单地点击或者勾选，就能下载安装和删除插件，建议选择的第一个Xcode插件。下载完成后通过Window—&gt;Package Manager来打开。 VVDocumenter - 规范注释生成器 VVDocumenter是一个规范化的代码注释插件，在协同开发的时候，每个人的代码风格不一样，那么必要的代码注释就显得很关键，那么VVDocumenter一定是最好的选择，在需要填写注释的属性和方法上下只需要输入三个斜线”///“，就能生成相应的代码注释了，支持Xcode和swift。 FuzzyAutocomplete - 代码自动补全插件FuzzyAutocompletePlugin是一个Xcode代码补全插件的插件，通过添加模糊匹配来提高Xcode代码自动补全功能，开发者无需遵循从头匹配的原则，只要记得方法里某个关键字即可进行匹配，很好地提高了工作效率。比系统自带的更高效，无需输入顺序即可匹配到相应代码。 ESJsonFormat - JSON格式化输出为模型的属性的插件可以通过json字符串自动生成属性，同时支持MJExtension，具体效果见下图： IconMaker - AppIcon一键生成神器只需简单几部操作就能生成一套icon，再也不需要一个个手动替换了，再也不需要应为icon大小不对审核被拒绝了，只需要一步一键生成，要多方便有多方便。 XAlign - 一个用来对齐常规代码的Xcode插件一个用来对齐常规代码的Xcode插件，十分强大的自定义对齐模式。只需键入command+shift+x就能自动帮你对齐你杂乱的代码了，强迫症专用。 KSImageNamed - 图片名自动补全插件为项目中使用的UIImage的imageNamed提供文件名自动补全功能。使用[UIImage imageNamed:@”xxx”]时，该插件会扫描整个workspace中的图片文件。 Backlight - 帮你找到当前正在输入位置的黑科技大家肯定遇到过，当你在输入时突然找不到输入光标在哪里了，这时候你能慢慢找，Backlight 帮你解决了这个问题，你不用再为找不到光标而烦恼了，绝对黑科技。 PS:今天就给大家分享到这里，这都是我用起来非常舒服的插件，以后有更好的我会在这里更新]]></content>
      <categories>
        <category>iOS开发进阶</category>
      </categories>
      <tags>
        <tag>Xcode</tag>
      </tags>
  </entry>
</search>
